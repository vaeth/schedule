#!/usr/bin/env perl
use strict;
use warnings;
use integer;
use File::Path qw(make_path);
use File::Spec;
use Getopt::Long;
use IO::Select;
use IO::Socket; # INET or UNIX, depending on user's choice
use Pod::Usage;

my $name = 'schedule-server';

sub version {
	print("$name 0.5\n");
	exit(0)
}

=head1 NAME

schedule-server - server for the schedule client; schedule man for details

=head1 SYNOPSIS

=over 8

=item B<schedule-server> [options]

Start server for the B<schedule> command.
Use B<schedule --help> or B<schedule --man> for a brief help or
verbose usage instructions, respectively.

=back

=head1 DESCRIPTION

This is a daemon which needs to run if the B<schedule> command shall be used.
(Versions of the daemon and of the B<schedule> command need to match.)
It can be started as a user or as root - it only needs permissions to setup a
TCP port or a unix domain socket, depending on the communication type
you choose. Only in special occassions it emits diagnostic messages on STDERR.
Note that this daemon does not background itself and does not generate a
PID file: Use a command line like "schedule-server &" or a script like
start-stop-daemon if you want that.
It should be completely safe to run this daemon as root, but to limit the
effect of unforeseen bugs, for security reasons, if the effective user id is 0,
this daemon tries to change its permissions to user and group "nobody".
If the user/group cannot be found, the id 65534 is used instead.

By default, the daemon uses a TCP socket on a local port for communication.
Note that this means that every user on the local machine can communicate
with the server and list/start/remove/change the order of queued commands
of all users using the same daemon. This is intentional, and you should be
aware of the security risks if you use this daemon globally.

If you do not want this, you can run this daemon locally, communicating by a
file (unix domain socket). In this case, you will usually run the daemon
locally as a user and specify the option B<--local>
(and/or B<--file>, B<--umask>).
It is recommended in this case, to setup an alias or a shell script
to call B<schedule> always with the same B<--local> or B<--file> option, too.

=head1 OPTIONS

The default of the options is taken from the environment variable
B<SCHEDULE_SERVER_OPTS> (shell-quoting in that variable is supported).
If that variable is undefined, the default is taken from the
environment variable B<SCHEDULE_OPTS>.

=over 8

=item B<--tcp> or B<-t>

Use a tcp socket (port) for IPC with the client(s). This is the default.
This option exists so that you can override an earlier specified
(e.g. set in B<SCHEDULE> or B<SCHEDULE_SERVER>) option B<-l>.

=item B<--local> or B<-l>

Use a unix domain socket (file) for IPC with the client(s).

=item B<--file=>I<file> or B<-f> I<file>

Use I<file> as a unix domain socket filename for IPC.
The default is B<${TMPDIR}/schedule-${USER}/server>.
All parent directories are created if they do not exist.
This option implies B<--local> (unless overridden later on).

=item B<--umask>I<umask> or B<-m> I<umask>

Use this umask for creating directories and/or unix domain socket file.
The argument is a number; prepend "0" to specify that it is octal.
Default is 0077. It may be a security risk to change this!

=item B<--skip-check> or B<-S>

Do not change ownership of the parent directory of I<file>.
Normally, this is checked since it can be a security risk if this is
not owned by a trusted user.
Do not use this option unless you know what you are doing!

=item B<--port=>I<port> or B<-P> I<port>

Use port number I<port>; default is B<8471>.
This option implies B<--tcp> (unless overridden later on).

=item B<--addr=>I<addr> or B<-A> I<addr>

Bind to I<addr>. The default is 127.0.0.1 (localhost only).
If you want to liste worldwide, use B<--addr 0.0.0.0> but be aware about
the security implications: Everybody will be able to start/see/re-order/cancel
your tasks!
This option implies B<--tcp> (unless overridden later on).

=item B<--keep-permissions> or B<-k>

Do not try to drop permissions, even if started as root.
It is equivalent to specify B<--no-change-user> and B<--no-change-group>.

=item B<--change-permission> or B<-K>

Try to drop permissions, even if not started as root.
It is equivalent to specify B<--change-user> and B<--change-group>.

=item B<--no-change-user> or B<-n>

Try to keep permissions of user, independently of how the group is treated.

=item B<--no-change-group> or B<-N>

Try to keep permissions of group (and associated groups),
ndependently of how the the user is treated.

=item B<--change-user> or B<-c>

Try to drop permissions of user, independently of how the group is treated.

=item B<--change-group> or B<-C>

Try to drop permissions of group (and associated groups),
independently of how the the user is treated.

=item B<--user=>I<user> or B<-u> I<user>

Drop permissions to user I<user> instead of B<nobody>.

=item B<--group=>I<group> or B<-g> I<group>

Drop permissions to group I<group> instead of B<nobody>.

=item B<--uid=>I<uid> or B<-U> I<uid>

Drop permissions to user with id I<uid> instead of 65534.
(If this is specified and valid the value of B<--user> is ignored.)

=item B<--gid=>I<gid> or B<-G> I<gid>

Drop permissions to user with id I<gid> instead of 65534.
(If this is specified and valid the value of B<--group> is ignored.)

=item B<--help> or B<-h>

Display brief help.

=item B<--man> or B<-?>

Display extended help as a manpage.

=back

=head1 COPYRIGHT AND LICENSE

Copyright Martin VE<auml>th.
This program is under the BSD License.

=head1 AUTHOR

Martin VE<auml>th E<lt>martin@mvath.deE<gt>

=cut

# Default for the Options:

my $timeout = 10;
my $tcp = 1;
my $addr = '127.0.0.1';
my $port = 8471;
my $file = undef;
my $umask = 0077;
my $skipcheck = '';
my $uid = '';
my $gid = '';
my $user = 'nobody';
my $group = 'nobody';
my $keepuser = $<;
my $keepgroup = $keepuser;

# Global/State variables:

my $len = 0x7FFFFFFF;
my $joblist = [];
my $unique = 0;
my $socket = undef;

#
# Functions
#

sub signal_handler {
	$SIG{INT} = $SIG{HUP} = $SIG{TERM} = sub {1};
	&send_exit(7);
	&closeserver();
	unlink($file) unless($tcp);
	exit(130);
}

sub openserver {
	$socket = ($tcp ? new IO::Socket::INET(
		LocalAddr => $addr,
		LocalPort => $port,
		Type => SOCK_STREAM(),
		Listen => SOMAXCONN(),
		Reuse => 1
	) : new IO::Socket::UNIX(
		Local => $file,
		Type => SOCK_STREAM(),
		Listen => SOMAXCONN(),
		Reuse => 1
	));
	unless(defined($socket)) {
		&fatal("unable to setup socket: $!");
		return ''
	}
	$SIG{INT} = $SIG{HUP} = $SIG{TERM} = \&signal_handler;
	1
}

sub conn_recv {
	my $conn = shift;
	my $tout = $_[1];
	my $select = IO::Select->new($conn);
	if(defined($tout) && $tout && !$select->can_read($tout)) {
		&error("timeout when reading socket");
		return ''
	}
	unless(defined($conn->recv($_[0], $len))) {
		&error("cannot receive from socket: $!");
		return ''
	}
	1
}

sub conn_send {
	my $conn = shift;
	defined($conn->send($_[0]))
}

sub closeserver {
	my $ret = 1;
	$ret = ''if(defined($socket) && !($socket->close()));
	unlink($file) unless($tcp || !(-S $file));
	$ret
}

sub serverloop {
	while(defined(my $conn = $socket->accept())) {
		my $will_close = 1;
		my $data;
		$data = '' unless(&conn_recv($conn, $data, $timeout));
		$data =~ s/^([^\n]*)\n?//;
		my $cmd = (defined($1) ? $1 : '');
		if(($cmd eq 'queue') || ($cmd eq 'start')) {
			$data =~ s/^([+-]?\d*)\n//;
			my $index = &my_index($2);
			my $stat = (($cmd eq 'start') ? '' : undef);
			++$unique;
			&conn_send($conn, $unique);
			splice(@$joblist, $index, 0, [$conn, $data, $stat, $unique, []]);
			$will_close = '' unless(defined($stat))
		} elsif(($cmd eq 'run') || ($cmd eq 'bg') || ($cmd eq 'wait')) {
			my $i = &my_index($data);
			my $reply = &indexname($i);
			if($reply eq '0') {
				&conn_send($conn, $reply);
			} else {
				my $job = $joblist->[$i];
				my $stat = &get_status($job);
				unless(defined($stat)) {
					if($cmd ne 'wait') {
						$stat = '';
						&set_status($job, $stat);
						&conn_send(&get_conn($job), 'run')
					}
				}
				&conn_send($conn, $reply);
				if($cmd ne 'bg') {
					if(defined($stat) && ($stat ne '')) {
						&conn_send($conn, $stat)
					} else {
						&push_wait($job, $conn);
						$will_close = ''
					}
				}
			}
		} elsif($cmd eq 'end') {
			$data =~ s/^([^\n]*)\n//;
			my $u = (defined($1) ? $1 : '');
			for my $j (@$joblist) {
				if(&get_unique($j) eq $u) {
					my $stat = &get_status($j);
					&send_finish($j, $data);
					&set_status($j, $data)
						if(defined($stat) &&
							($stat eq ''));
					last
				}
			}
		} elsif($cmd eq 'cancel') {
			while(1) {
				$data =~ s/^(\d+)\n//;
				my $stat = (defined($1) ? $1 : 0);
				my $index = &my_index($data);
				my $reply = &indexname($index);
				if($reply ne '0') {
					my $job = $joblist->[$index];
					$reply .= "\n-" unless(&send_remove($job, $stat));
					&send_finish($job, $stat);
					&set_status($job, $stat)
				}
				last unless(&conn_send($conn, $reply));
				last unless(&conn_recv($conn, $data, $timeout));
				last unless($data =~ s/^cancel\n?//)
			}
		} elsif(($cmd eq 'list') || ($cmd eq 'status')) {
			while(1) {
				my $i = &my_index($data);
				my $reply = &indexname($i);
				if($reply ne '0') {
					my $job = $joblist->[$i];
					my $stat = &get_status($job);
					$stat = (defined($stat) ? $stat : '-');
					$reply .= "\n$stat";
					$reply .= "\n" . &get_cmd($job)
						if($cmd eq 'list')
				}
				last unless(&conn_send($conn, $reply));
				last unless(&conn_recv($conn, $data, $timeout));
				last unless($data =~ s/^(list|status)\n?//);
				$cmd = $1
			}
		} elsif($cmd eq 'insert') {
			$data =~ s/([^\n]*\n)//;
			my $index = &my_index($1);
			my @insert = ();
			for my $i (&unique_indices($data)) {
				push(@insert, $joblist->[$i]);
				$joblist->[$i] = undef
			}
			my $oldlist = $joblist;
			$joblist = [];
			for(my $i = 0; $i < $index; ++$i) {
				my $j = $oldlist->[$i];
				push(@$joblist, $j) if(defined($j))
			}
			push(@$joblist, @insert);
			for(my $i = $index; $i < @$oldlist; ++$i) {
				my $j = $oldlist->[$i];
				push(@$joblist, $j) if(defined($j))
			}
		} elsif($cmd eq 'remove') {
			$data =~ s/^(\d+)\n//;
			my $stat = (defined($1) ? $1 : 0);
			my @fail = ();
			for my $i (&unique_indices($data)) {
				my $job = $joblist->[$i];
				push(@fail, &indexname($i))
					unless(&send_remove($job, $stat));
				&send_finish($job, $stat);
				$joblist->[$i] = undef
			}
			my $oldlist = $joblist;
			$joblist = [];
			for(my $i = 0; $i < @$oldlist; ++$i) {
				my $j = $oldlist->[$i];
				push(@$joblist, $j) if(defined($j))
			}
			&conn_send($conn, join(' ', @fail) . "\n")
		} elsif($cmd eq 'stop') {
			$data =~ /^(\d+)/;
			my $stat = (defined($1) ? $1 : 0);
			my @fail = &send_exit($stat);
			my $ret = &conn_send($conn, join(' ', @fail) . "\n");
			$ret = '' if(@fail);
			$ret = '' unless($conn->close());
			return $ret
		}
		$conn->close() if($will_close)
	}
	''
}

sub send_exit {
	my ($stat) = @_;
	my @fail = ();
	for(my $i = 0; $i < @$joblist; ++$i) {
		my $job = $joblist->[$i];
		push(@fail, &indexname($i)) unless(&send_remove($job, $stat));
		&send_finish($job, $stat)
	}
	@fail
}

sub send_remove {
	my ($job, $stat) = @_;
	return 1 if(defined(&get_status($job)));
	my $ret = 1;
	my $conn = &get_conn($job);
	$ret = '' unless(&conn_send($conn, $stat));
	$conn->close() && $ret
}

sub send_finish {
	my ($job, $stat) = @_;
	while(defined(my $conn = &shift_wait($job))) {
		&conn_send($conn, $stat)
	}
}

sub get_conn {
	$_[0]->[0]
}

sub get_cmd {
	$_[0]->[1]
}

sub get_status {
	$_[0]->[2]
}

sub set_status {
	$_[0]->[2] = $_[1]
}

sub get_unique {
	$_[0]->[3]
}

sub shift_wait {
	my $wait = $_[0]->[4];
	shift(@$wait)
}

sub push_wait {
	my ($j, $p) = @_;
	my $wait = $j->[4];
	push(@$wait, $p)
}

# return unique list of internal indices corresponding to index names

sub unique_indices {
	my %have = ();
	my @ret = ();
	my ($ind) = @_;
	$ind = '' unless(defined($ind));
	for my $name (split(/\s+/, $_[0])) {
		if($name =~ /^(\d*)\:(\d*)$/) {
			my $i = (($1 eq '') ? 1 : $1);
			my $end = &my_index($2);
			for($i = &my_index($i); $i <= $end; ++$i) {
				next if(exists($have{$i}));
				$have{$i} = 1;
				push(@ret, $i)
			}
			next
		}
		my $i = &my_index($1);
		next if(exists($have{$i}));
		$have{$i} = 1;
		push(@ret, $i)
	}
	@ret
}

# return name corresponding to internal index $i

sub indexname {
	my ($i) = @_;
	return '0' if($i == @$joblist);
	++$i;
	"$i"
}

# return internal index of array corresponding to $1

sub my_index {
	my ($arg) = @_;
	$arg = 0 unless(defined($arg) && ($arg =~ /^[+-]?\d+$/));
	my $max = scalar(@$joblist);
	return $max if($arg > $max);
	return ($arg - 1) if($arg > 0);
	$arg += $max;
	if($arg < 0) {
		0
	} else {
		$arg
	}
}

# Split shell-quoted string into words

sub split_quoted {
	my ($arg) = @_;
	my @res = ();
	my $word = undef;
	my $quoting = '';
	while($arg ne '') {
		my $add;
		if(($arg =~ s/\A([^\"\'\s\\]+)//m) ||
			($arg =~ s/\A\\(.)//m) || ($arg =~ s/^(\\)$//) ||
			($arg =~ s/\A\'((?:[^\'])*)\'?//m)) {
				$add = $1;
		} elsif($arg =~ s/\A(\s+)//m) {
			unless($quoting) {
				if(defined($word)) {
					push(@res, $word);
					$word = undef
				}
				next
			}
			$add = $1
		} else {
			$arg =~ s/^\"//;
			$quoting = !$quoting;
			next
		}
		if(defined($word)) {
			$word .= $1
		} else {
			$word = $1
		}
	}
	push(@res, $word) if(defined($word));
	@res
}

sub fatal {
	print(STDERR "$name: error: ",
		join("\n" . (' ' x (length($name) + 9)), @_), "\n");
	exit(1)
}

sub error {
	print(STDERR "$name: error: ",
		join("\n" . (' ' x (length($name) + 9)), @_), "\n")
}

sub warning {
	print(STDERR "$name: warning: ",
		join("\n" . (' ' x (length($name) + 11)), @_), "\n")
}

sub is_nonnegative {
	my ($i) = @_;
	(defined($i) && ($i =~ /^\d+$/))
}

sub prepare_file {
	umask($umask);
	unless(defined($file)) {
		my $user = getpwuid($<);
		$user = $< unless(defined($user) && ($user ne ''));
		$file = File::Spec->catfile(File::Spec->tmpdir(),
			'schedule-' . $user, 'server')
	}
	my ($vol, $dir) = File::Spec->splitpath($file);
	$dir = File::Spec->catpath($vol, $dir);
	return 1 if($dir eq '');
	(-d $dir) || make_path($dir) || &fatal("cannot create directory $dir");
	my @stat = lstat($dir);
	&fatal("cannot find directory $dir") unless(@stat);
	return 1 if($skipcheck);
	&fatal("$dir owned by " . $stat[4] . ':' . $stat[5] . ' instead of '
		. $< . ':' . $(,
	"This may be a security risk. If it is intentional use option -S")
		if(($stat[4] != $<) || ($stat[5] != $())
}

#
# Now the main program:
#

if(exists($ENV{'SCHEDULE_SERVER_OPTS'})) {
	unshift(@ARGV, &split_quoted($ENV{'SCHEDULE_SERVER_OPTS'}))
} elsif(exists($ENV{'SCHEDULE_OPTS'})) {
	unshift(@ARGV, &split_quoted($ENV{'SCHEDULE_OPTS'}))
}

# Parse Options:

$Getopt::Long::bundling = 1;
GetOptions(
	'help|h', sub { pod2usage(1) },
	'man|?', sub { pod2usage(-verbose => 2) },
	'version|V', \&version,
	'tcp|t', \$tcp,
	'local|l', sub { $tcp = '' },
	'port|P=i', sub { $tcp = 1; $port = $_[1] },
	'addr|A=s', sub { $tcp = 1; $addr = $_[1] },
	'file|f=s', sub { $tcp = ''; $file = $_[1] },
	'umask|m=s', \$umask,
	'skip-check|S', \$skipcheck,
	'timeout|T=i', \$timeout,
	'uid|U=s', \$uid,
	'gid|G=s', \$gid,
	'user|u=s', \$user,
	'group|g=s', \$group,
	'change-user|c', sub { $keepuser = '' },
	'no-change-user|n', \$keepuser,
	'change-group|C', sub { $keepgroup = '' },
	'no-change-group|N', \$keepgroup,
	'change-permissions|K', sub { $keepuser = $keepgroup = '' },
	'keep-permissions|k', sub { $keepuser = $keepgroup = 1 }
) or pod2usage(2);

# First, drop permissions if possible:

unless($keepgroup) {
	unless(&is_nonnegative($gid)) {
		if($group =~ /^[a-zA-Z0-9]+$/) {
			$gid = getgrnam($user);
			unless(&is_nonnegative($gid)) {
				&warning("cannot get group id of $group. Falling back to 65534");
				$gid = 65534
			}
		} else {
			$gid = 65534
		}
	}
	$) = ($gid);
	$) = $gid if($!);
	&warning("failed to set egid to $gid: $!") if($!);
	$( = $gid;
	&warning("failed to set gid to $gid: $!") if($!)
}

unless($keepuser) {
	unless(&is_nonnegative($uid)) {
		if($user =~ /^[a-zA-Z0-9]+$/) {
			$uid = getpwnam($user);
			unless(&is_nonnegative($uid)) {
				&warning("cannot get group id of $group. Falling back to 65534");
				$uid = 65534
			}
		} else {
			$uid = 65534
		}
	}
	$> = $uid;
	&warning("failed to set euid to $uid: $!") if($!);
	$< = $uid;
	&warning("failed to set uid to $uid: $!") if($!)
}

# Postprocess options:

&fatal("illegal timeout $timeout") unless(&is_nonnegative($timeout));
&fatal("illegal port $port") unless(&is_nonnegative($port) && $port <= 0xFFFF);
&prepare_file() unless($tcp);


# Process arguments:

pod2usage(2) if(@ARGV);

# Call main functions:

my $exitstatus = ((&openserver() && &serverloop()) ? 0 : 1);
$exitstatus = 1 unless(&closeserver());
exit($exitstatus);
