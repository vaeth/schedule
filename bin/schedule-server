#!/usr/bin/env perl
# Copyright Martin VÃ¤th <martin@mvath.de>.
# This is part of the schedule project.
use strict;
use warnings;
use integer;
use File::Path ();
use File::Spec ();
#use Crypt::Rijndael (); # needed for password protection
#use Digest::SHA (); # needed for password protection
#use Exporter qw(import);
#use Getopt::Long ();
#use IO::Select ();
#use IO::Socket (); # INET or UNIX, depending on user's choice
#use POSIX (); # needed for --detach (and recommended for --bg, --daemon)
#use Pod::Usage (); # optional, but no manpage or help without this
#use Sys::Hostname (); # not mandatory but recommended
#use Term::ANSIColor (); # not mandatory but recommended: fallback to no color

use lib '/usr/share/schedule';
use FindBin;
if(($FindBin::Bin // '') ne '') {
	use lib File::Spec->catdir($FindBin::Bin, File::Spec->updir(), 'lib');
	use lib File::Spec->catdir($FindBin::Bin, 'lib');
	use lib $FindBin::Bin
}
use Schedule::Connect ();
use Schedule::Helpers qw(env_to_array is_nonnegative);

our $VERSION = '5.0';

# Global/State variables:

my $s = Schedule::Connect->new('schedule-server', $VERSION);

# Default for the Options:

my $umask = 0077;
my $skipcheck = '';
my $uid = '';
my $gid = '';
my $user = 'nobody';
my $group = 'nobody';
my $keepuser = $<;
my $keepgroup = $keepuser;

#
# Functions
#

sub prepare_file {
	$s->default_filename();
	umask($umask);
	my ($vol, $dir) = File::Spec->splitpath($s->file());
	$dir = File::Spec->catpath($vol, $dir);
	return 1 if($dir eq '');
	$s->fatal('cannot create directory ' . $dir)
		unless((-d $dir) || File::Path::make_path($dir));
	my @stat = lstat($dir);
	$s->fatal('cannot find directory ' . $dir) unless(@stat);
	return 1 if($skipcheck);
	$s->fatal($dir . ' owned by ' . $stat[4] . ':' . $stat[5] .
		' instead of ' . $< . ':' . $(,
	'This may be a security risk. Use -S if it is intentional')
		if(($stat[4] != $<) || ($stat[5] != $())
}

#
# Now the main program:
#

if(exists($ENV{'SCHEDULE_SERVER_OPTS'})) {
	unshift(@ARGV, &env_to_array('SCHEDULE_SERVER_OPTS'))
} elsif(exists($ENV{'SCHEDULE_OPTS'})) {
	unshift(@ARGV, &env_to_array('SCHEDULE_OPTS'))
}

# Parse Options:

$s->get_options(
	'umask|m=s', \$umask,
	'skip-check|S', \$skipcheck,
	'uid|U=s', \$uid,
	'gid|G=s', \$gid,
	'user|u=s', \$user,
	'group|g=s', \$group,
	'change-user|c', sub { $keepuser = '' },
	'no-change-user|n', \$keepuser,
	'change-group|C', sub { $keepgroup = '' },
	'no-change-group|N', \$keepgroup,
	'change-permissions|K', sub { $keepuser = $keepgroup = '' },
	'keep-permissions|k', sub { $keepuser = $keepgroup = 1 }
);

# First, drop permissions if possible:

unless($keepgroup) {
	unless(&is_nonnegative($gid)) {
		if($group =~ m{^\w+$}) {
			$gid = getgrnam($group);
			unless(&is_nonnegative($gid)) {
				$s->warning("cannot get group id of $group. Falling back to 65534");
				$gid = 65534
			}
		} else {
			$gid = 65534
		}
	}
	$) = ($gid);
	$) = $gid if($!);
	$s->warning('failed to set egid to $gid:', $!) if($!);
	$( = $gid;
	$s->warning('failed to set gid to $gid:', $!) if($!)
}

unless($keepuser) {
	unless(&is_nonnegative($uid)) {
		if($user =~ m{^\w+$}) {
			$uid = getpwnam($user);
			unless(&is_nonnegative($uid)) {
				$s->warning("cannot get user id of $user. Falling back to 65534");
				$uid = 65534
			}
		} else {
			$uid = 65534
		}
	}
	$> = $uid;
	$s->warning("failed to set euid to $uid:", $!) if($!);
	$< = $uid;
	$s->warning("failed to set uid to $uid:", $!) if($!)
}

# Postprocess options:

$s->check_options();

# Process arguments:

$s->usage(2) if(@ARGV);

# Call main functions:

&prepare_file() unless($s->tcp());

require Schedule::Server::Serverfuncs;
require Schedule::Server::Loop;

Schedule::Server::Serverfuncs->import(qw(:INIT));

&server_init($s);
exit(1) unless(&openserver($s));
unless($s->did_alpha()) {
	my $ret = $s->exec_alpha();
	exit($ret) if($ret);
	$s->forking()
}
my $succ = &Schedule::Server::Loop::serverloop();
$succ = '' unless(&closeserver());
exit($succ ? 0 : 1);
