#!/usr/bin/env perl
# Copyright Martin VÃ¤th <martin@mvath.de>.
# This is part of the schedule project.
use strict;
use warnings;
use integer;
use File::Spec ();
use IO::Socket (); # INET or UNIX, depending on user's choice
#use Crypt::Rijndael (); # needed for password protection
#use Cwd ();
#use Digest::SHA (); # needed for password protection
#use Exporter qw(import);
#use Getopt::Long ();
#use IO::Select ();
#use POSIX (); # needed for --detach
#use Pod::Usage (); # optional, but no manpage or help without this
#use Sys::Hostname (); # not mandatory but recommended
#use Term::ANSIColor (); # not mandatory but recommended: fallback to no color

use lib '/usr/share/schedule';
use FindBin;
if(($FindBin::Bin // '') ne '') {
	use lib File::Spec->catdir($FindBin::Bin, File::Spec->updir(), 'lib');
	use lib File::Spec->catdir($FindBin::Bin, 'lib');
	use lib $FindBin::Bin
}
use Schedule::Common::Connect ();
use Schedule::Common::Helpers qw(env_to_array is_nonnegative join_quoted);

our $VERSION = '4.0';

# Global/State variables:

my $s = Schedule::Common::Connect->new('schedule', $VERSION);

# Default for the Options:

my $cancel = 0;
my $nouser = '';
my $nohost = '';
my $nodir = '';
my $nocommand = '';
my $keepdir = '';
my $destjob = 0;
my $tests = [[], [], []];

#
# Commands
#

sub cmd_queue {
	require Schedule::Cmd::Queue;
	&Schedule::Cmd::Queue::queue(@_, $destjob, $cancel, $keepdir, $tests)
}

sub cmd_run {
	require Schedule::Cmd::Run;
	&Schedule::Cmd::Run::run(@_)
}

sub cmd_parallel {
	require Schedule::Cmd::Parallel;
	&Schedule::Cmd::Parallel::parallel(@_)
}

sub cmd_list {
	require Schedule::Cmd::List;
	&Schedule::Cmd::List::list(@_, $nouser, $nohost, $nodir, $nocommand)
}

sub cmd_test {
	require Schedule::Cmd::Test;
	&Schedule::Cmd::Test::test(@_)
}

sub cmd_cancel {
	require Schedule::Cmd::Cancel;
	&Schedule::Cmd::Cancel::cancel($cancel)
}

sub cmd_remove {
	require Schedule::Cmd::Remove;
	&Schedule::Cmd::Remove::remove($cancel)
}

sub cmd_stop_server {
	require Schedule::Cmd::Remove;
	&Schedule::Cmd::Remove::remove($cancel, 1)
}

sub cmd_insert {
	require Schedule::Cmd::Insert;
	&Schedule::Cmd::Insert::insert($destjob)
}

#
# Functions
#

sub check_file {
	my $default = $s->default_filename();
	my $file = $s->file();
	return 1 if(-S $file);
	$s->error("no socket $file exists", 'maybe you should run first: ' .
		&join_quoted('schedule-server', '--daemon',
			($default ? '-l' : ('-f', $file))));
	exit(7)
}

#
# Now the main program:
#

if(exists($ENV{'SCHEDULE_OPTS'})) {
	unshift(@ARGV, &env_to_array('SCHEDULE_OPTS'))
}

# Parse Options:

$s->get_options(
	'exit|e=i', \$cancel,
	'no-user|nouser|u', \$nouser,
	'no-host|nohost|H', \$nohost,
	'no-dir|nodir|D', \$nodir,
	'no-command|nocommand|c', \$nocommand,
	'keep-dir|keepdir|d', \$keepdir,
	'job|j=i', \$destjob,
	'ok|o=s', $tests->[0],
	'finished|x=s', $tests->[1],
	'started|s=s', $tests->[2]
);

# Postprocess options:

$s->check_options();
$s->fatal("illegal --exit $cancel")
	unless(&is_nonnegative($cancel) && $cancel <= 0xFF);
&check_file() unless($s->tcp());

# Load main functions:

require Schedule::Client::Clientfuncs;
Schedule::Client::Clientfuncs->import(qw(:INIT));
&client_init($s);

# Process command:
my $action = shift(@ARGV) // '';
my $ret;
if($action =~ m{^sto}i) {
	$ret = &cmd_stop_server()
} elsif($action =~ m{^(?:re|d)}i) {
	$ret = &cmd_remove()
} elsif($action =~ m{^r}i) {
	$ret = &cmd_run('run')
} elsif($action =~ m{^(?:e|x)}i) {
	$ret = &cmd_run('exec')
} elsif($action =~ m{^b}i) {
	$ret = &cmd_parallel('')
} elsif($action =~ m{^p}i) {
	$ret = &cmd_parallel(1)
} elsif($action =~ m{^w}i) {
	$ret = &cmd_run('wait')
} elsif($action =~ m{^l}i) {
	$ret = &cmd_list('list')
} elsif($action =~ m{^stat}i) {
	$ret = &cmd_list('status')
} elsif($action =~ m{^a}i) {
	$ret = &cmd_list('address')
} elsif($action =~ m{^n}i) {
	$ret = &cmd_list('number')
} elsif($action =~ m{^o}i) {
	$ret = &cmd_test($tests, 0)
} elsif($action =~ m{^f}i) {
	$ret = &cmd_test($tests, 1)
} elsif($action =~ m{^starte}i) {
	$ret = &cmd_test($tests, 2)
} elsif($action =~ m{^(?:i|m|sh)}i) {
	$ret = &cmd_insert()
} elsif($action =~ m{q.*s|s.*q}i) {
	$ret = &cmd_queue('start-or-queue')
} elsif($action =~ m{^q}i) {
	$ret = &cmd_queue('queue')
} elsif($action =~ m{^s}i) {
	$ret = &cmd_queue('start')
} elsif($action =~ m{^c}i) {
	$ret = &cmd_cancel()
} else {
	$s->usage(2)
}
&client_exit($ret);
