#!/usr/bin/env perl
use strict;
use warnings;
use integer;
use Cwd;
use Pod::Usage;
use File::Spec;
use IO::Select;
use IO::Socket; # INET or UNIX, depending on user's choice
#use Sys::Hostname;   # not mandatory but recommended
#use Term::ANSIColor; # not mandatory but recommended: fallback to no color
#use Crypt::Rijndael; # needed for password protection
#use Digest::SHA;     # needed for password protection
#use POSIX;           # needed for --detach


use lib '/usr/share/schedule';
use FindBin;
if(($FindBin::Bin // '') ne '') {
	use lib File::Spec->catdir($FindBin::Bin, File::Spec->updir(), 'lib');
	use lib File::Spec->catdir($FindBin::Bin, 'lib');
	use lib $FindBin::Bin
}
use Schedule::Helpers qw(/./);
use Schedule::Connect;
my $s = Schedule::Connect->new('schedule', '3.0');

=head1 NAME

schedule - queue jobs for later execution and schedule them

=head1 SYNOPSIS

=over 8

=item B<schedule> [options] B<queue>|B<start>|B<start-or-queue> I<cmd> [I<args> ...]

=item B<schedule> [options] I<command> [I<jobs> ...]

=item B<schedule> [options] I<stop-server>

=back

I<command> is one of:

B<run>, B<exec>, B<bg>, B<parallel>, B<wait>, B<list>, B<status>,
B<ok>, B<finished>, B<started>, B<cancel>, B<remove>, B<insert>,
B<address>, B<number>

commands can be shortcut by the shortest sequence which makes them unique.
For instance, B<q> can be used instead of B<queue>, B<r> instead of B<run>.
B<s> (despite being non-unique) can be used instead of B<start>.
Moreover, B<start-or-queue> can be abbreviated as anything containing B<s>
and B<q>.

I<jobs> is either a job number, a job address (absolute or relative),
a job range, or a job address range, see the section B<SPECIFYING JOBS>.
Each I<jobs> can also start with a leading B</>
which indicates that the range (or value) is considered static.
If no I<jobs> arguments are given, the value B<:> is assumed
(which means to select all jobs).

The exit status is usually the largest exit status of the scheduled command.
In case of a fatal communication error (e.g. server not started) the
exit status 7 is returned.

To get an extended help, type B<schedule man>

=head1 DESCRIPTION

The idea of this project is that you can B<queue> jobs by "starting"
them e.g. in different shells (possibly with different users or in chroots)
and by using various commands.

The "queued" jobs are not immediately executed but only in the moment when
you B<run> them from some scheduler script.
This scheduler script is meant to be a very simple ad-hoc script and can
even be a single shell command like

=over 8

B<schedule run>

=back

(this example would simply execute all queued jobs sequentially).

=head1 EXAMPLE 1

To initialize the whole system you must run eventually B<schedule init>
(this can be run from your machines init system).

Then run in three different shells the three commands

=over 8

=item B<schedule start-or-queue emerge -NDu @world>

=item B<schedule start-or-queue revdep-rebuild>

=item B<schedule start-or-queue shutdown -h now>

=back

and then in a fourth shell B<schedule run>.
Then the above three commands will be executed in order.
If during the execution you realize that you want to cancel execution of the
last command, you just press Ctrl-C in the shell where you started the last
command and use other B<schedule> calls to e.g. insert something before the
last command. Then you invoke the above command again.

=head1 EXAMPLE 2

Run in different shells the following commands

=over 8

=item B<schedule calculate 1>

=item B<schedule calculate 2>

=item B<schedule calculate 3>

=item B<schedule shutdown -h now>

=back

and then in a further shell

=over 8

=item B<schedule run 1> && B<schedule parallel 2:3> && B<schedule run>

=back

This runs first B<calculate 1> and upon a succesfull finishing
B<calculate 2> and B<calculate 3> in parallel.
When both are succesfully finished, B<shutdown -h now> is executed.

=head1 OPTIONS

The default of the options is taken from the environment variable
B<SCHEDULE_OPTS>; shell-quoting in the value is supported.
Moreover, (unquoted) environment variable references of the form $VAR
or ${VAR} in it are (recursively) expanded.

=over 8

=item B<--tcp> or B<-t>

Use a tcp socket (port) for IPC with the client(s). This is the default.
This option exists so that you can override an earlier specified
(e.g. set in B<SCHEDULE>) option B<-l>.

=item B<--local> or B<-l>

Use a unix domain socket (file) for IPC with the server.

=item B<--file=>I<file> or B<-f> I<file>

Use I<file> as a unix domain socket filename for IPC.
The default is B<${TMPDIR}/schedule-${USER}/server>.
This option implies B<--local> (unless overridden later on).

=item B<--port=>I<port> or B<-P> I<port>

Use port number I<port>; default is B<8471>.
This option implies B<--tcp> (unless overridden later on).

=item B<--addr=>I<addr> or B<-A> I<addr>

Bind to I<addr>. The default is 127.0.0.1 (localhost only).
This option implies B<--tcp> (unless overridden later on).

=item B<--timeout=>I<seconds> or B<-T> I<seconds>

Time to wait in case of communication problems; the default is 10 B<seconds>.
The value B<0> means to skip the timeout.

=item B<--passfile=>I<password-file> or B<-Y> I<password-file>

Read the first line from I<password-file> (without the newline)
and use it as a password to encrypt communication between B<schedule>
and B<schedule-server>. Both programs must use the same password for a
succesfull communication.

This option can be used accumulatively:
The first existing I<password-file> with a nonempty first line is used.
If no such file is found, this option is tacitly ignored.
This is to make it safe to specify this option in B<SCHEDULE_OPTS>
or B<SCHEDULE_OPTS> if no corresponding file exists.

=item B<--password=>I<password> or B<-y> I<password>

This is like B<--passfile>, with the difference that you specify the
password directly. This option is dangerous, because many systems allow
other users to see the commandline/environment (hence the password is visible).

=item B<--job=>I<jobnr> or B<-j> I<jobnr>

This describes where the job(s) should be inserted into the queue.
The special number B<0> means the end of the queue
(which may be the number of the last queued job or one later, depending
on the selected action); negative numbers count from the end of the list.
The default is B<0>.

This means e.g. that B<schedule queue> will by default queue new jobs after
the end of the queue while e.g. B<schedule insert> will shift the selected
jobs (in their order of selection) to the end of the queue.

=item B<--ok=>I<jobs> or B<-o> I<jobs>

This option can be used repeatedly; all arguments are collected.
I<jobs> can be as in the normal argument list (space-separated).
If used with B<start-or-queue>, B<ok>, B<finished>, B<started>,
check whether the listed jobs have been finished with zero exit status.

=item B<--background> or B<--bg> or B<-b>

For commands which are expected to be waiting (B<queue>, B<start-or-queue>
if the condition for immediate start are not satisfied, B<exec>, B<run>)
fork into background and return before the actual waiting begins.
To use this option, your system must know fork(), of course.

This is similar to using the B<&> in a shell, but in contrast to the latter,
a sequence of such commands does not give a race condition.
For instance, if you use B<schedule queue command1 & schedule queue command2 &>
it is partially random whether B<command1> is indeed queued in fron of
B<command1>.
By using instead B<schedule --bg command1 && schedule --bg command2>
this cannot happen.

This option is ignored for B<schedule --bg parallel>, since
B<schedule bg> has a similar effect but does not need to fork.

=item B<--daemon> or B<-B>

This is like B<--background>, but it also partially detaches from terminal
and discards all subsequent standard input/output.

=item B<--detach> or B<-E>

This is like B<--daemon>, but fully detaches from terminal, discarding also
error output. To use this option, your perl must have a functioning POSIX.
To avoid unexpected issues with relatice paths, the current working directory
is kept (and thus remains occupied). Therefore you might want to change to the
root directory before using this option.

=item B<--finished=>I<jobs> or B<-x> I<jobs>

This option can be used repeatedly; all arguments are collected.
I<jobs> can be as in the normal argument list (space-separated).
If used with B<start-or-queue>, B<ok>, B<finished>, B<started>,
check whether the listed jobs have been finished, independent of their
exit status.

=item B<--started=>I<jobs> or B<-s> I<jobs>

This option can be used repeatedly; all arguments are collected.
I<jobs> can be as in the normal argument list (space-separated).
If used with B<start-or-queue>, B<ok>, B<finished>, B<started>,
check whether the listed jobs have been started (finished jobs
are considered as started).

=item B<--no-user> or B<--nouser> or B<-u>

If this option is specified, B<schedule list> will suppress the output of
user, hostname, and B<HOSTTEXT>.

=item B<--no-host> or B<--nohost> or B<-H>

If this option is specified, B<schedule list> will suppress the output of
B<HOSTTEXT>. By default, the value of B<HOSTTEXT> is output in braces;
this can be used to indicate e.g. whether the command is scheduled from
a chroot (and from which). If B<HOSTTEXT> is not specified, the output
of B<uname -m> is used as a default (if nonempty).

=item B<--no-dir> or B<--nodir> or B<-D>

If this option is specified, B<schedule list> will suppress the output of
the current working directory for the scheduled command.

=item B<--no-command> or B<--nocommand> or B<-c>

If this option is specified, B<schedule list> will suppress the output of
the queued command.

=item B<--keep-dir> or B<--keepdir> or B<-d>

If this option is specified with B<queue>, B<start>, or B<start-or-queue>,
the current working directory is not shortcut using the B<HOME>
environment variable. This influences the later output with B<schedule list>.

=item B<--exit=>I<exitstatus> or B<-e> I<exitstatus>

Sets the I<exitstatus> for unscheduled jobs. The default is B<0>.

=item B<--color> or B<-F>

Try to color even if output is not a terminal.

=item B<--no-color> or B<--nocolor> or B<-p>

Do not color the output.
Setting the environment variable B<ANSI_COLORS_DISABLED> has the same effect.

=item B<--quiet> or B<-q> (accumulative)

Be quiet.

=item B<--help> or B<-h>

Display brief help.

=item B<--man> or B<-?>

Display extended help as a manpage.

=back

=head1 COMMANDS

=over 8

=item B<queue> I<cmd> [I<args> ... I<args>]

Queue I<cmd> I<args> ... I<args> for execution.
The command will be exuted using the shell.

=item B<start> I<cmd> [I<args> ... I<args>]

As B<queue>, but start the command immediately without waiting for a
further signal through B<schedule>.

=item B<start-or-queue> I<cmd> [I<args> ... I<args>]

Act as B<start> if all jobs specified through the options
B<--ok>, B<--finished>, B<--started> meet the corresponding requirements;
otherwise act as B<queue>.
If none of the options B<--ok>, B<--finished>, or B<--started> is specified,
act as if B<--finished :> would have been specified, that is, B<start> is
executed only if there is not any unfinished job in the queue.

=item B<run> I<jobs>

Starts the selected jobs (sequentially) if they have not already
been started. The exit status is the largest exit status of all I<jobs>.
If a job has already been started, the command will wait for its finishing.
If it already has been finished it is not started again, but the exit status
is taken into account.

The command is not race-free, that is, it is somewhat similar to calling
B<schedule run> I<job> for each I<job> separately (for job ranges of the
type B<:> or I<start>B<:> the end being changed dynamically).

This is intentional so that modification of the job queue has effect
to the command while it is running. If you do not want this, see the details
in the section B<SPECIFYING JOBS>: Static job numbers or static job ranges
are not subject to this race condition, Also jobs addresses avoid this
race condition in a sense.

=item B<exec> I<jobs>

This is like B<schdeule run> but breaks further execution if a job exits
with nonzero status. Note that also finished jobs can have nonzero exit status.

Similarly to B<run>, this command is not race-free, but static jobs and
static job ranges are supported.

=item B<wait> I<jobs>

This waits until all specified jobs have been finished and
returns the largest exit status.

Similarly to B<run>, this command is not race-free, but static jobs and
static job ranges are supported.

=item B<bg> I<jobs>

This is similar to B<schedule run> but starts all non-started B<jobs> in
parallel without ever waiting (and then returns).
In contrast to the B<--bg> option, no process is forked.
In contrast to B<schedule run>, this command is not subject to a race
condition.

=item B<parallel> I<jobs>

This is similar to running B<schedule bg> followed by B<schedule wait>
where all arguments are interpreted as B<static> jobs/job ranges.
However, this would have a race (if the queue is modified between the two
commands) which is avoided with B<schedule parallel>.

In other words, B<parallel> starts the specified jobs in background and
waits for them to finish, even if the queue is extended or ordered differently
during the execution of these jobs.

Similarly to B<run> with static jobs there is one exception of this rule:
If commands are removed from the queue while the commands are running,
they are considered to be finished, and their exit status is assumed to be 0.

=item B<list> I<jobs>

Lists the queued jobs, their addresses, their exit status (or whether
they are waiting/running, respectively), the user/host/current directory and
command line of the scheduled commands. The output can be influenced
by the options B<--no-user>, B<--no-host>, B<--no-dir>, or B<--no-command>.

=item B<status> I<jobs>

This is a script-friendly variant of B<schedule list>:
It outputs only the exit status of the selected job (or "waiting" or
"running"), respectively, each output followed by a newline.
If a job is not in the queue, the value B<-> is output.

If used with B<--quiet>, nothing is output (except perhaps warnings/errors),
but the exit status is different: It is the largest exit status of all
finished I<jobs>. If used with B<--quiet>, it is an error if a job cannot
be found (and in this case the exit status is at least 1).

=item B<address> I<jobs>

This is a script-friendly variant of B<schedule list>:
This outputs the job addresses of the specified I<jobs>
(each output followed by a newline).
If a job cannot be found, the value B<0> is output.

=item B<number> I<jobs>

This is a script-friendly variant of B<schedule list>:
This outputs the number of the specified I<jobs> in the queue
(each output followed by a newline).
If a job cannot be found, the value B<0> is output.

For instance, B<schedule number 0> will effectively output the length of the
queue (since the last job number in the queue is its length, and B<0> is
output if there is no such job).

=item B<ok>|B<finished>|B<started>

This is a more script-friendly and race-free form of B<status>,
without any output (except in error cases):
It returns with exit status 0 if all jobs specified through the options
B<--ok>, B<--finished>, B<--started> meet the corresponding requirements.
(The I<jobs> arguments are quivalent to using the corresponding
B<--ok>, B<--finished>, or B<--started> options with these arguments,
respectively.)
If none of these options is specified and no I<jobs> argument is given,
acts as if the argument B<:> is given for I<jobs>.
If the exit status is nonzero, it is the maximum of B<1> and of all exit values
of jobs specified through B<--ok>.

=item B<remove> I<jobs>

Remove I<jobs> from the list of B<queued> jobs.
Note that if the job is already started it is not stopped, but its exit status
cannot be queried through B<schedule> anymore.

=item B<insert> I<jobs>

The list of queued jobs is ordered differently by shifting all specified I<jobs>
to to the location specified with B<--job>. Thus, if B<--job=1>,
all I<jobs> are shifted to the beginning of the list (renumbering the
previously first jobs). The special value B<--job=0> (default)
means to shift to the end of the list, and negative numbers count from the
end of the list. For instance B<schedule --job=-1 insert :2> will shift the
first two jobs one command before the end of the list.

=item B<cancel> I<jobs>

If I<jobs> are not yet started they will never be started.
If they are running, their exit status will be ignored.
The scheduler is forced to assume that the jobs finished with the
exitstatus specified by B<--cancel> (default is B<0>).

=item B<address> I<jobs>

This outputs the job addresses of the specified I<jobs>
(each output followed by a newline).

=back

=head1 SPECIFYING JOBS

Whenever you have to pass a parameter which specifies a job,
you can do this by specifying the job number.
In this case, the number refers to the number in the queue.

If you specify the number 0 or a negative number, the counting is backwards
from the queue.

Note that the association of a number to the job can change when you rearrange
the queue (by the B<insert> or B<delete> command or by queuing new jobs
not at the end of the queue).
For this reason, there is also a possibility to specify jobs by their
addresses. A job address has the form B<@>I<number> and can be seen by
the output of the B<list> or B<address> command.
Such a job address does never change. However, it can become invalid:
If the job is removed from the queue, the address becomes invalid.

Besides these (absolute) job addresses, it is also possible to specify
relative job addresses which have the form B<@>I<number><summand>.
For instance, if you want to address that job which comes in the queue
immediately after the job with the address B<@5>, you would specify B<@5+1>.
Similarly, B<@4-5> means the job which comes in the queue 5 places before
job B<@4>.

In most occassions you can enter also job ranges or job address ranges.

A job range has the form I<from>B<:>I<to> where I<from> and I<to>
are job numbers or (relative or absolute) job addresses.
A job range consists of all jobs from the queue between B<from> and B<to>
(boundaries inclusive); if B<from> is omitted, the range consists of all jobs
in the queue until B<to> (inclusive) and if B<to> is ommitted, the range
consists of all jobs in the queue starting from B<from> (inclusive).
If B<to> comes before B<from> in the queue then the range is empty.

Some examples of job ranges:

=over 8

=item B<1:3>
B<:3>

These are both equivalent and mean the first three jobs in the queue.

=item B<-2:>

This gives the last three jobs in the queue (-2, -1, and 0).

=item B<:>

This means all jobs in the queue. This is the default, for instance,
if you specify no further arguments after B<schedule run>.

=item B<2:1>

This strange example specifies an empty job range. You can use this if
for some reason you want to override the default B<:> and really want to
specify B<no> jobs (although this hardly ever makes any sense).

=item B<@2:@1>

This can be a nonempty job range, since it can happen that the job with
address B<@2> appears in the queue before that with address B<@1>.

=item B<@1-1:@1+2>

This consists of 4 jobs: The job in the queue before that with address B<@1>,
then the job B<@1>, and the two subsequent ones in the queue.

=item B<@1+1:@1>

This is the empty range (or an error if there is no job with address B<@1>
in the queue).

=back

A job address range has the form I<from>B<_>I<to>, where I<from> and I<to>
are (absolute or relative) job addresses. This is just a convenience shortcut
and means all addresses with address numbers between that from I<from> and
I<to>. (The queue is ignored here.)

If you specify relative addresses in I<from> and I<to>, the summand may occur
either in I<from> or in I<to>, but it is invalid to specify different
summands, of course.

Some examples of job address ranges:

=over 8

=item B<@1_@3>

The range consists of the three jobs with addresses B<@1>, B<@2>, and B<@3>.

=item B<@2_@1>

This is the empty range. Not to be confused with B<@2:@1> which can be
nonempty (see the earlier examples).

=item B<@2-1_@4-1> or B<@2-1_@4> or B<@2_@4-1>

These all mean the same, namely the three jobs with the relative addressses
B<@2-1>, B<@3-1>, and B<@4-1>. In other words, these are the three jobs in the
queue before those with the respective job addresses B<@2>, B<@3>, and B<@4>.

=item B<@2-1_@4-2>

This makes no sense.

=back

All job numbers, job addresses, job ranges, and job address ranges can also
be marked to be "static". This makes only sense for the commands
B<exec>, B<run>, and B<wait> which can be subject to a race condition.

Marking a range or an address as "static" is similar to specifying a
corresponding absolute job address or absolute job address range,
where the address is resolved in the moment when the command is started.
The only differences is that the job address(es) are also associated with
the server, that is, the corresponding job is considered to be removed from
the queue even if the schedule-server has been shut down and restarted and
another job with the same address has been queued with that new
schedule-server.

To mark a range or an address static, simply preceed it with "/".
You can mark only a whole range (or address range) static, not individual
addresses in it. For example, B</1:2> means that the whole range B<1:2>
is considered to be static; the syntax B<1:/2> is invalid.

Examples with static ranges:

=over 8

=item B<schedule run /5:7 /0 /: :>

This will run the jobs 5, 6, 7, and the last from the current queue, followed
by all of the rest of the current queue, followed by all commands which are
possibly added to the queue until this happens.

=item B<schedule run /:4 /5:0>

=item B<schedule run /:0>

=item B<schedule run /:>

These are all equivalent: They start all jobs of the current queue
successively, independent of later modifications of the queue.

=item B<schedule run :4 5:0>

=item B<schedule run :0>

=item B<schedule run :>

In contrast to the previous example, these are not equivalent:
They differ in the moment when B<0> is evaluated (and replaced by the
last number in the queue). In the first case, B<0> is evaluated in the
moment when the 5th job gets started, in the second case immediately,
and in the last case changes in the length of the queue are always honoured.

=item B<schedule run @1_@4>

=item B<schedule run /@1_@4>

Despite job addresses are used, these two commands are not completey
equivalent: the latter binds the addresses also to the server
as mentioned before, that is, it is not possible to "trick" it by
exchanging the server and starting new jobs with addreses B<@2> B<@3>,
or B<@4> (job B<@1> is started immediately, so for this job there is no race).

=item B<schedule run @1 /@1+1>

The last argument looks like a relative job address, but it only partially
behaves like such: It is the job which is queued after the job with the
address B<@1> when the command is executed, even if that queue will change
while that job is running. Without the B</> symbol the job actually referred
to might change.

=back

=head1 COPYRIGHT AND LICENSE

Copyright Martin VE<auml>th.
This program is under a BSD type License.

=head1 AUTHOR

Martin VE<auml>th E<lt>martin@mvath.deE<gt>

=cut

# Default for the Options:

my $cancel = 0;
my $nouser = '';
my $nohost = '';
my $nodir = '';
my $nocommand = '';
my $keepdir = '';
my $destjob = 0;
my @ok = ();
my @finished = ();
my @started = ();

# Global/State variables:

my $unique = undef;
my $socket = undef;
my $exitstatus = 0;
my $devnull = File::Spec->devnull();
my %known_ats = ();

#
# Commands
#

sub cmd_stop_server {
	return '' unless(&openclient() && &client_send("stop\n$cancel"));
	&client_recv(my $fail);
	unless($s->quiet()) {
		chomp($fail);
		$s->error("jobs failed to close: $fail") if($fail ne '')
	}
	&closeclient();
	1
}

sub cmd_have {
	my ($type) = @_;
	&validate_jobs(\@ARGV);
	if(@ARGV) {
		push(@$type, @ARGV);
		&nonempty_have()
	} elsif(!&nonempty_have()) {
		push(@$type, ':')
	}
	return '' unless(&openclient() &&
		&client_send('have' . &have_args()) &&
		&client_recv(my $reply));
	return '' unless(&is_nonnegative($reply));
	&set_exitstatus($reply);
	1
}

sub cmd_queue {
	my ($runmode) = @_;
	my $have = ($runmode eq 'start-or-queue');
	if($have) {
		push(@finished, ':') if(&nonempty_have());
		$runmode .= &have_args();
	}
	return '' unless(&openclient());
	&signals();
	my $cmd = '[' .  &my_user() . '@' . &my_hostname() .
		'(' . &my_hosttext() . ')' .
		&my_cwd() . ']' . &join_quoted(@ARGV);
	my $success = &client_send("$runmode\n$destjob\n$cmd");
	$success = '' unless(&client_recv($unique));
	if($have) {
		$unique =~ m{^([^\n]*)\n(.*)};
		$runmode = $1;
		$unique = $2
	}
	&signals(\&cancel_job);
	return '' unless($success);
	if($runmode eq 'queue') {
		$s->forking();
		&client_recv(my $stat, 0);
		unless(($stat // '') eq 'run') {
			$exitstatus = (&is_nonnegative($stat) ? $stat : $cancel);
			return 1
		}
	}
	return '' unless(&closeclient());
	my $sys = system(@ARGV);
	if($sys < 0) {
		$s->error('job could not be executed') unless($s->quiet());
		$sys = 127
	} elsif($sys & 127) {
		$s->error('job died with signal ' . ($sys & 127) .
			(($sys & 128) ? '' : ' (core dumped)'))
				unless($s->quiet());
		$sys = 127
	} else {
		$sys >>= 8;
		$s->error("exit with status " . $sys) if($sys && !$s->quiet());
	}
	&set_exitstatus($sys);
	&send_status($sys)
}

sub cmd_run {
	my ($runmode) = @_;
	&validate_jobs();
	return '' unless(&static_argv());
	my $send = $runmode;
	$send = 'run' if($runmode eq 'exec');
	$send .= "\n";
	$s->forking();
	for my $a (@ARGV) {
		for(my $iter = &start_end($a, undef, 1);
			$iter->unfinished(); $iter->increase()) {
			return '' unless(&runner($send . $iter->current(),
				my $job, my $status, 1));
			if($job eq '0') {
				last unless($iter->cond_error());
				&set_exitstatus(1);
				next
			}
			if($status) {
				&set_exitstatus($status);
				return 1 if($runmode eq 'exec')
			}
		}
	}
	1
}

sub cmd_parallel {
	my ($waiting) = @_;
	&validate_jobs();
	return '' unless(&openclient());
	my %unique_ids = ();
	my $last = undef;
	for my $a (@ARGV) {
		for(my $iter = &start_end($a, \$last);
			$iter->unfinished(); $iter->increase()) {
			return '' unless(&runner("bg\n" . $iter->current(),
				my $job, my $stat));
			if($job eq '0') {
				last unless($iter->cond_error());
				&set_exitstatus(1);
				next
			}
			next unless($waiting);
			if($stat eq '') {
				$unique_ids{$job} = undef
			} elsif($stat) {
				&set_exitstatus($stat)
			}
		}
	}
	&client_send('close');
	return '' unless(&closeclient());
	return 1 unless($waiting);
	for my $id (keys(%unique_ids)) {
		return '' unless(&runner("wait\n$id", my $job, my $stat, 1));
		&set_exitstatus($stat) if(($job ne '0') && $stat)
	}
	1
}

{ # Some static variables:
	my $col_reset = undef;
	my $col_waiting = undef;
	my $col_running = undef;
	my $col_nojob = undef;
	my $col_ok = undef;
	my $col_failed = undef;
	my $col_meta = undef;
	my $col_job;
	my $col_addr;
sub cmd_list {
	my ($type) = @_;
	&validate_jobs();
	my $last = undef;
	my $is_open = '';
	my $send = $type;
	$send = 'status' if($type ne 'list');
	$send .= "\n";
	for my $a (@ARGV) {
		for(my $iter = &start_end($a, \$last, \$is_open);
			$iter->unfinished(); $iter->increase()) {
			return '' unless($is_open || &openclient());
			$is_open = 1;
			my $reply;
			return '' unless(&client_send($send . $iter->current()) &&
				&client_recv($reply) &&
				($reply =~ s{^(\d+)\n?}{}));
			my $job = $1;
			my ($addr, $stat, $found);
			my $quiet = ($s->quiet());
			if($job eq '0') {
				$found = '';
				my $no_error = (($type eq 'number') ||
					($type eq 'address') ||
					(($type eq 'status') && !$quiet));
				last unless($iter->cond_error($quiet ||
					$no_error));
				unless($no_error) {
					&set_exitstatus(1);
					next
				}
			} else {
				$found = 1;
				$reply =~ s{^([^\n]*)\n?}{};
				$addr = ($1 // '');
				if($type ne 'list') {
					$stat = $reply
				} else {
					$reply =~ s{^([^\n]*)\n?}{};
					$stat = ($1 // '')
				}
				if($quiet) {
					&set_exitstatus($stat) if($stat &&
						($type eq 'status'));
					next
				}
			}
			my $use_color = $s->color_stdout();
			my $reset = ($use_color ?
				($col_reset //= &my_color('reset')) : '');
			my $statspace = ' ';
			if(!$found) {
				$statspace = (' ' x 7);
				$stat = '-';
				if($use_color) {
					$col_nojob //= &my_color('bold red');
					$stat = $col_nojob . $stat . $reset
				}
			} elsif($stat eq '-') {
				$stat = ($use_color ? ($col_waiting //=
					&my_color('bold blue')) : '')
					. 'waiting' . $reset
			} elsif($stat eq '') {
				$stat = ($use_color ? ($col_running //=
					&my_color('bold yellow')) : '')
					. 'running' . $reset
			} elsif(&is_nonnegative($stat)) {
				$statspace = (' ' x (8 - length($stat)));
				$stat = ($stat ? ($col_failed //=
					&my_color('bold red')) :
					($col_ok //= &my_color('bold green')))
					. $stat . $reset if($use_color)
			} else {
				$s->fatal('strange server reply');
				return ''
			}
			if($type eq 'status') {
				print($stat . "\n");
				next
			}
			if($use_color && !defined($col_meta)) {
				$col_meta = &my_color('cyan');
				$col_job = &my_color('bold');
				$col_addr = &my_color('bold cyan')
			}
			if($type eq 'address') {
				if($use_color) {
					print(($found ? $col_addr : $col_nojob),
						$addr, $reset, "\n")
				} else {
					print($addr, "\n")
				}
				next
			}
			if($type eq 'number') {
				if($use_color) {
					print(($found ? $col_job : $col_nojob),
						$job, $reset, "\n")
				} else {
					print($job, "\n")
				}
				next
			}
			if($reply =~ s{\[([^@]*)@([^\(]*)\(([^\)]*)\)([^\]]*)\]}{}) {
				$reply = &format_cmd($use_color, $1, $2, $3, $4, $reply)
			} elsif($nocommand) {
				$reply = ''
			}
			my $jobspace = ((length($job) < 3) ?
				(' ' x (3 - length($job))) : '');
			my $addrspace = ((length($addr) < 4) ?
				(' ' x (4 - length($addr))) : '');
			if($use_color) {
				print($jobspace, $col_job, $job, $reset,
				$addrspace, $col_addr, $addr, $reset,
				$statspace, $col_meta, '(', $stat,
				$col_meta, ')', $reset, $reply, "\n")
			} else {
				print($jobspace, $job, $addrspace, $addr,
				$statspace, '(', $stat, ')', $reply, "\n")
			}
		}
	}
	return 1 unless($is_open);
	&client_send('close')
}
# Subfunction of cmd_list to format "[user@host(hosttext)dir] cmd"
# In case $use_color, the variables $col_reset, $col_meta are expected.
  # Some static variables:
	my $col_user = undef;
	my $col_host;
	my $col_dir = undef;
sub format_cmd {
	my ($use_color, $user, $host, $hosttext, $dir, $cmd) = @_;
	$cmd = ($nocommand ? '' : ' ' . $cmd);
	my $nopwd = ($nodir || ($dir eq ''));
	return $cmd if($nouser && $nopwd);
	if($use_color) {
		unless($nouser || defined($col_user)) {
			$col_user = &my_color('yellow');
			$col_host = &my_color('green')
		}
		unless($nopwd || defined($col_dir)) {
			$col_dir = &my_color('bold green')
		}
	}
	my $reply = ($use_color ? (' ' . $col_meta . '[') : ' [');
	$reply .= ($use_color ? ($col_user . $user . $col_meta . '@' .
		$col_host . $host . $col_meta) : ($user . '@' . $host)) .
		(($nohost || ($hosttext eq '')) ? ($nopwd ? '' : ':' )
		: ('(' . $hosttext . ')')) unless($nouser);
	$reply .= ($use_color ? ($col_dir . $dir . $col_reset . $col_meta)
		: $dir) unless($nopwd);
	$reply .= ']';
	$reply .= $col_reset if($use_color);
	$reply . $cmd
}}

sub cmd_cancel {
	&validate_jobs();
	my $last = undef;
	my $is_open = '';
	for my $a (@ARGV) {
		for(my $iter = &start_end($a, \$last, \$is_open);
			$iter->unfinished(); $iter->increase()) {
			return '' unless($is_open || &openclient());
			$is_open = 1;
			my $reply;
			return '' unless(&client_send("cancel\n$cancel\n",
				$iter->current()) && &client_recv($reply));
			my ($job, $stat) = split(qr{\s+}, $reply);
			if($job eq '0') {
				last unless($iter->cond_error());
				&set_exitstatus(1);
				next
			}
			if($stat) {
				&set_exitstatus(1);
				$s->error("job $job failed to close")
			}
		}
	}
	return 1 unless($is_open);
	&client_send('close')
}

sub cmd_remove {
	&validate_jobs();
	return '' unless(&openclient() &&
		&client_send("remove\n$cancel\n" . join(' ', @ARGV)) &&
		&client_recv(my $failed));
	my @fail = split(qr{\s+}, $failed);
	if(@fail) {
		&set_exitstatus(1);
		$s->error('jobs failed to close: ' . join(' ',@fail))
	}
	1
}

sub cmd_insert {
	&validate_jobs();
	&openclient() && &client_send("insert\n$destjob\n" . join(' ', @ARGV))
}

#
# Functions
#

{ # A static variable:
	my $checked = '';
sub openclient {
	$socket = ($s->tcp() ? new IO::Socket::INET(
		PeerAddr => $s->addr(),
		PeerPort => $s->port(),
		Type => SOCK_STREAM
	) : new IO::Socket::UNIX(
		Peer => $s->file(),
		Type => SOCK_STREAM()
	));
	unless(defined($socket)) {
		my $silence = (shift() // '');
		$s->error("unable to setup socket: $!",
			'maybe you should run first: schedule-server --daemon')
			unless($silence);
		return ''
	}
	return 1 if($checked);
	my $ver;
	if(&client_send('version') && &client_recv($ver) &&
		&is_nonempty($ver)) {
		unless($ver eq $s->version()) {
			$s->error('schedule-server ' . $ver .
				' does not match schedule ' . $s->version());
			return ''
		}
	} else {
		$s->error('cannot connect to socket');
		return ''
	}
	$checked = 1
}}

sub client_recv {
	return 1 if($s->conn_recv($socket, @_));
	&closeclient(1);
	exit(7)
}

sub client_send {
	$s->conn_send($socket, @_)
}

sub closeclient {
	return 1 unless(defined($socket));
	my $ret = ($socket->close());
	$socket = undef;
	return 1 if($ret);
	my $silence = (shift() // '');
	$s->error("failed to close socket: $!") unless($silence);
	''
}

sub runner {
	my $send = shift();
	my $nowait = !($_[2] // '');
	return '' unless($nowait || &openclient());
	my $reply;
	my $ret = (&client_send($send) &&
		&client_recv($reply) &&
		($reply =~ m{^([^\n]*)\n?(\d*)\n?}));
	$_[0] = my $num = $1;
	my $stat = $2;
	unless($nowait || ($num eq '0') || &is_nonnegative($stat)) {
		$ret = '' unless(&client_recv($stat, 0) &&
			(($stat eq '') || &is_nonnegative($stat)))
	}
	$_[1] = $stat;
	($nowait || &closeclient()) && $ret
}

sub static_argv {
	my @new = ();
	my %know = ();
	my $last = undef;
	my $is_open = '';
	my $have_static = '';
	for my $a (@ARGV) {
		unless($a =~ s{^\/}{}) {
			push(@new, $a);
			next
		}
		for(my $iter = &start_end($a, \$last, \$is_open);
			$iter->unfinished(); $iter->increase()) {
			my $i = $iter->current();
			my $result = $know{$i};
			unless(defined($result)) {
				unless($have_static) {
					return '' unless($is_open || &openclient());
					$have_static = $is_open = 1
				}
				return '' unless(&client_send("unique\n$i") &&
					&client_recv($result));
				$know{$i} = $result
			}
			if($result eq '0') {
				last unless($iter->cond_error());
				&set_exitstatus(1);
				next
			}
			push(@new, $result . "\n" . $i . "\n" . $a)
		}
	}
	return ((!$is_open) || &closeclient()) unless($have_static);
	@ARGV = @new;
	&client_send('close') && &closeclient()
}

sub send_status {
	# Sending exitstatus must cause no errors/warnings:
	&client_send("end\n$unique\n$exitstatus") if(&openclient(1));
	&closeclient(1);
	1
}

# Cancel a job (if "schedule queue" is interrupted by a signal):

sub cancel_job {
	&signals();
	&closeclient(1);
	#&send_status($cancel);
	&openclient(1) &&
		&client_send("cancel\n$cancel\n" . ($unique // $destjob)) &&
		&client_recv(my $reply) &&
		&client_send('close');
	exit($cancel)
}


# Check whether @ARGV (resp. passed array reference) are valid job
# specifications.
# Let @ARGV = (':') if there are none (unless array reference is passed).

sub validate_jobs {
	my ($array) = @_;
	unless(defined($array)) {
		unless(@ARGV) {
			@ARGV = (':');
			return
		}
		$array = \@ARGV
	}
	for my $i (@$array) {
		my ($valid) = $s->decode_range($i);
		$s->fatal('invalid job specification: ' . &join_quoted($i))
			unless(defined($valid))
	}
}

# Normalize and validate the value of @ok, @finished, @started.
# Return true if at least one is nonempty.

sub nonempty_have {
	my $ret = '';
	for my $a (\@ok, \@finished, \@started) {
		$ret = 1 if(@$a);
		@$a = split(' ', join(' ', @$a));
		&validate_jobs(1, $a)
	}
	$ret
}

# Return passed string for the value of @ok, @finished, @started

sub have_args {
	my $ret = '';
	for my $a (\@ok, \@finished, \@started) {
		$ret .= "\n" . join(' ', @$a)
	}
	$ret
}

# Iterator constructor:
# Get job specification according to passed string.
# For nonpositive numbers use the second argument as the largest job number
# instead of querying the server.
# The second argument can also be a reference in which case the result
# (if queried) is stored in that variable.
# If querying, open a new connection if the third argument is true or
# a reference with a false value. In the former case close the connection
# again, in the latter case set the reference to true.
# The return value is a class of type Iterator with subsequent methods

sub start_end {
	my $a = shift();
	my $self = bless {
		finished => '',
		atbeg => undef,
		beg => undef,
		sep => '',
		atend => undef,
		end => undef
	};
	if($a =~ m{^u}) {
		$self->{atbeg} = '';
		($self->{beg}, $self->{atend}, $self->{end}) = split(m{\n}, $a);
		return $self
	}
	my ($atbeg, $beg, $sep, $atend, $end) = $s->decode_range($a);
	unless(defined($atbeg)) {
		$self->{finished} = 1;
		return $self
	}
	($self->{atbeg}, $self->{beg}, $self->{sep}) = ($atbeg, $beg, $sep);
	return $self if($sep eq '');
	($self->{atend}, $self->{end}) = ($atend, $end);
	return $self if($sep eq '_');
	my $beglast = (($atbeg eq '') && ($beg <= 0));
	my $endlast = (($atend eq '') && ($end ne '') && ($end <= 0));
	return $self unless($beglast || $endlast ||
		($atbeg ne '') || ($atend ne ''));
	my ($lastref, $openref) = @_;
	my $last = undef;
	my $is_open = undef;
	my $noclose = 1;
	my $s_open = sub {
		return $is_open if(defined($is_open));
		$openref = '' unless(defined($openref));
		if(ref($openref) eq '') {
			$is_open = $noclose = !$openref
		} else {
			$is_open = ($$openref // '');
			$$openref = $noclose = 1
		}
		unless($is_open || &openclient()) {
			$noclose = 1;
			return ''
		}
		$is_open = 1
	};
	my $s_close = sub {
		return if($noclose);
		&client_send('close');
		&closeclient();
		$noclose = 1
	};
	my $s_last = sub {
		return &is_nonnegative($last) if(defined($last));
		$last = ((ref($lastref) eq '') ? $lastref : $$lastref);
		return 1 if(&is_nonnegative($last));
		return '' unless(&{$s_open}());
		&client_send("status\n0") &&
			&client_recv($last) &&
			($last //= '') &&
			($last =~ s{^(\d+).*}{$1});
		$last //= '';
		&is_nonnegative($last)
	};
	my $s_at = sub {
		my ($at) = @_;
		my $ret = $known_ats{$at};
		return $ret if(defined($ret));
		return '' unless(&{$s_open}());
		return '' unless(&client_send("status\n\@$at") &&
			&client_recv($ret) &&
			defined($ret) &&
			$ret =~ m{^(\d+)});
		$known_ats{$at} = $1;
	};
	my $s_add = sub {
		my ($at, $addref) = @_;
		my $ret = &{$s_at}($at);
		$s->warning('nonexistent job address: @' . $at)
			if(($ret ne '') && !$ret);
		if($ret && ($$addref ne '')) {
			$$addref += $ret
		} else {
			$$addref = $ret
		}
		$ret
	};
	my $s_error = sub {
		$self->{finished} = 1;
		&{$s_close}();
		return $self
	};
	if($beglast || $endlast) {
		return &{$s_error}() unless(&{$s_last}());
		$self->{beg} = $beg += $last if($beglast);
		$self->{end} = $end += $last if($endlast)
	}
	if($atbeg ne '') {
		return &{$s_error}() unless(&{$s_add}($atbeg, \$beg));
		$self->{atbeg} = '';
		$self->{beg} = $beg
	}
	if($atend ne '') {
		return &{$s_error}() unless(&{$s_add}($atend, \$end));
		$self->{atend} = '';
		$self->{end} = $end
	}
	if(($beg <= 0) || (($end ne '') && ($end <= 0))) {
		$s->warning('job number out of range: ' . $a);
		$self->{beg} = 1 if($beg <= 0);
		return &{$s_error}() if(($end ne '') && ($end <= 0))
	}
	&{$s_close}();
	$self
}

# Iterator method to check whether a current value is available.

sub unfinished {
	my $self = shift();
	return '' if($self->{finished});
	my $ret;
	my $sep = $self->{sep};
	if($sep eq '') {
		$ret = 1
	} elsif($sep eq '_') {
		$ret = ($self->{atbeg} <= $self->{atend})
	} else {
		my $end = $self->{end};
		$ret = (($end eq '') || ($self->{beg} <= $end))
	}
	$self->{finished} = !$ret;
	$ret
}

# Iterator method to increase the current value in a range.
# Also single values are considered as ranges.
# When the end is reached, the method current can no longer be used.

sub increase {
	my $self = shift();
	return $self if($self->{finished});
	my $sep = $self->{sep};
	if($sep eq '') {
		$self->{finished} = 1
	} elsif($sep eq '_') {
		++($self->{atbeg})
	} else {
		++($self->{beg})
	}
	$self
}

# Iterator method to return the current value,
# with true argument in a human-readable form, otherwise appropriate for
# passage to schedule-server.
# This method requires that the unfinished method returns true.

sub current {
	my $self = shift();
	return undef if($self->{finished});
	my $atbeg = $self->{atbeg};
	my $beg = $self->{beg};
	if($atbeg eq '') {
		return $beg unless(($_[0] // '') && ($self->{sep} eq '') &&
			($atbeg eq '') && ($beg =~ m{^u}));
		my ($here, $all) = ('/' . $self->{atend}, $self->{end});
		return (($here eq $all) ? $here : $here . ' (' . $all . ')')
	}
	$atbeg = '@' . $atbeg;
	return $atbeg unless($beg);
	$beg = '+' . $beg if($beg > 0);
	$atbeg . $beg
}

# Iterator method to output the error that a job is unavailable.
# Do not output (and return '' if it is the "normal" end of an open-ended
# range ("x:"); otherwise return true.
# The actual output is omitted if the true argument is passed.
# If no argument is passed, $s->quit() is used.

sub cond_error {
	my $self = shift();
	my $sep = $self->{sep};
	return '' if(($sep eq ':') && ($self->{end} eq ''));
	$s->error('unavailable job ' . $self->current(1))
		unless($_[0] // $s->quiet());
	1
}

# increase exitstatus to argument

sub set_exitstatus {
	my ($stat) = @_;
	$exitstatus = $stat if($exitstatus < $stat)
}

sub check_file {
	my $default = $s->default_filename();
	my $file = $s->file();
	return 1 if(-S $file);
	$s->error("no socket $file exists", 'maybe you should run first: ' .
		&join_quoted('schedule-server', '--daemon',
			($default ? '-l' : ('-f', $file))));
	exit(7)
}

{ my $hostname = undef; # a static closure
sub my_hostname {
	return $hostname if(defined($hostname));
	$hostname = $ENV{'HOSTNAME'};
	unless(&is_nonempty($hostname)) {
		eval {
			require File::Which;
			File::Which->import();
			$hostname = hostname()
		};
		$hostname = '' unless($@ && defined($hostname))
	}
	$hostname =~ s{[\(\)\[\]\:]}{.}g;
	$hostname
}}

{ my $hosttext = undef; # a static closure
sub my_hosttext {
	return $hosttext if(defined($hosttext));
	$hosttext = $ENV{'HOSTTEXT'};
	unless(defined($hosttext)) {
		my $olderr = undef;
		$olderr = undef unless(open($olderr, '>&', \*STDERR) && open(STDERR, '>', $devnull));
		$hosttext = (`uname -m` // '');
		open(STDERR, '>&', $olderr) if(defined($olderr));
		chomp($hosttext)
	}
	$hosttext =~ s{[\(\)\[\]]}{.}g;
	$hosttext
}}

{ my $cwd = undef; # a static closure
sub my_cwd {
	return $cwd if(defined($cwd));
	$cwd = (getcwd() // '');
	unless($keepdir) {
		my $home = $ENV{'HOME'};
		if(&is_nonempty($home)) {
			if($home eq $cwd) {
				$cwd = '~'
			} else {
				my $len = length($home);
				$cwd = '~' . substr($cwd, $len) if(
				($len < length($cwd)) &&
				(substr($cwd, 0, $len + 1) eq ($home . '/')))
			}
		}
	}
	$cwd =~ s{[\[\]]}{?}g;
	$cwd
}}

#
# Now the main program:
#

if(exists($ENV{'SCHEDULE_OPTS'})) {
	unshift(@ARGV, &env_to_array('SCHEDULE_OPTS'))
}

# Parse Options:

$s->get_options(
	'exit|e=i', \$cancel,
	'no-user|nouser|u', \$nouser,
	'no-host|nohost|H', \$nohost,
	'no-dir|nodir|D', \$nodir,
	'no-command|nocommand|c', \$nocommand,
	'keep-dir|keepdir|d', \$keepdir,
	'job|j=i', \$destjob,
	'ok|o=s', \@ok,
	'finished|x=s', \@finished,
	'started|s=s', \@started
);

# Postprocess options:

$s->check_options();
$s->fatal("illegal --exit $cancel")
	unless(&is_nonnegative($cancel) && $cancel <= 0xFF);
&check_file() unless($s->tcp());

# Process command:

my $action = shift(@ARGV) // '';
my $ret;
if($action =~ m{^sto}i) {
	$ret = &cmd_stop_server()
} elsif($action =~ m{^(?:re|d)}i) {
	$ret = &cmd_remove()
} elsif($action =~ m{^r}i) {
	$ret = &cmd_run('run')
} elsif($action =~ m{^(?:e|x)}i) {
	$ret = &cmd_run('exec')
} elsif($action =~ m{^b}i) {
	$ret = &cmd_parallel('')
} elsif($action =~ m{^p}i) {
	$ret = &cmd_parallel(1)
} elsif($action =~ m{^w}i) {
	$ret = &cmd_run('wait')
} elsif($action =~ m{^l}i) {
	$ret = &cmd_list('list')
} elsif($action =~ m{^stat}i) {
	$ret = &cmd_list('status')
} elsif($action =~ m{^a}i) {
	$ret = &cmd_list('address')
} elsif($action =~ m{^n}i) {
	$ret = &cmd_list('number')
} elsif($action =~ m{^o}i) {
	$ret = &cmd_have(\@ok)
} elsif($action =~ m{^f}i) {
	$ret = &cmd_have(\@finished)
} elsif($action =~ m{^starte}i) {
	$ret = &cmd_have(\@started)
} elsif($action =~ m{^(?:i|m|sh)}i) {
	$ret = &cmd_insert()
} elsif($action =~ m{q.*s|s.*q}i) {
	$ret = &cmd_queue('start-or-queue')
} elsif($action =~ m{^q}i) {
	$ret = &cmd_queue('queue')
} elsif($action =~ m{^s}i) {
	$ret = &cmd_queue('start')
} elsif($action =~ m{^c}i) {
	$ret = &cmd_cancel()
} else {
	pod2usage(2)
}
$exitstatus = 7 unless(&closeclient() && $ret);
exit($exitstatus);
