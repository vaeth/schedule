#!/usr/bin/env perl
use strict;
use warnings;
use integer;
use Cwd;
use Pod::Usage;
use File::Spec;
use IO::Select;
use IO::Socket; # INET or UNIX, depending on user's choice
#use Sys::Hostname;   # not mandatory but recommended
#use Term::ANSIColor; # not mandatory but recommended: fallback to no color

use lib '/usr/share/schedule';
use FindBin;
if(defined($FindBin::Bin) && ($FindBin::Bin ne '')) {
	use lib File::Spec->catdir($FindBin::Bin, File::Spec->updir(), 'lib');
	use lib File::Spec->catdir($FindBin::Bin, 'lib');
	use lib $FindBin::Bin
}
use Schedule::Helpers qw(/./);
use Schedule::Connect;
my $s = Schedule::Connect->new('schedule', '0.14');

=head1 NAME

schedule - queue jobs for later execution and schedule them

=head1 SYNOPSIS

=over 8

=item B<schedule> [options] B<queue>|B<start>|B<start-or-queue> I<cmd> [I<args> ...]

=item B<schedule> [options] I<command> [I<jobs> ...]

=item B<schedule> [options] I<stop-server>

=back

I<command> is one of:

B<run>, B<exec>, B<bg>, B<parallel>, B<wait>, B<list>, B<status>,
B<ok>, B<finished>, B<started>, B<cancel>, B<remove>, B<insert>

commands can be shortcut by the shortest sequence which makes them unique.
For instance, B<q> can be used instead of B<queue>, B<r> instead of B<run>.
B<s> (despite being non-unique) can be used instead of B<start>.
Moreover, B<start-or-queue> can be abbreviated as anything containing B<s>
and B<q>.

I<jobs> is either a job numbers or a string of the form I<from>B<:>I<to>
where I<from> and B<to> may be omitted (and then mean 1 or infinity,
respectively). If no I<jobs> argument is given, it defaults to B<:>.

Exit status is usually the largest exit status of the scheduled command.
In case of a fatal communication error (e.g. server not started) the
exit status 7 is returned.

To get an extended help, type B<schedule man>

=head1 DESCRIPTION

The idea of this project is that you can B<queue> jobs by "starting"
them e.g. in different shells (possibly with different users or in chroots)
and by using various commands.

The "queued" jobs are not immediately executed but only in the moment when
you B<run> them from some scheduler script.
This scheduler script is meant to be a very simple ad-hoc script and can
even be a single shell command like

=over 8

B<schedule run>

=back

(this example would simply execute all queued jobs sequentially).

=head1 EXAMPLE 1

To initialize the whole system you must run eventually B<schedule init>
(this can be run from your machines init system).

Then run in three different shells the three commands

=over 8

=item B<schedule start-or-queue emerge -NDu @world>

=item B<schedule start-or-queue revdep-rebuild>

=item B<schedule start-or-queue shutdown -h now>

=back

and then in a fourth shell B<schedule run>.
Then the above three commands will be executed in order.
If during the execution you realize that you want to cancel execution of the
last command, you just press Ctrl-C in the shell where you started the last
command and use other B<schedule> calls to e.g. insert something before the
last command. Then you invoke the above command again.

=head1 EXAMPLE 2

Run in different shells the following commands

=over 8

=item B<schedule calculate 1>

=item B<schedule calculate 2>

=item B<schedule calculate 3>

=item B<schedule shutdown -h now>

=back

and then in a further shell

=over 8

=item B<schedule run 1> && B<schedule parallel 2:3> && B<schedule run>

=back

This runs first B<calculate 1> and upon a succesfull finishing
B<calculate 2> and B<calculate 3> in parallel.
When both are succesfully finished, B<shutdown -h now> is executed.

=head1 OPTIONS

The default of the options is taken from the environment variable
B<SCHEDULE_OPTS>; shell-quoting in the value is supported.
Moreover, (unquoted) environment variable references of the form $VAR
or ${VAR} in it are (recursively) expanded.

=over 8

=item B<--tcp> or B<-t>

Use a tcp socket (port) for IPC with the client(s). This is the default.
This option exists so that you can override an earlier specified
(e.g. set in B<SCHEDULE>) option B<-l>.

=item B<--local> or B<-l>

Use a unix domain socket (file) for IPC with the server.

=item B<--file=>I<file> or B<-f> I<file>

Use I<file> as a unix domain socket filename for IPC.
The default is B<${TMPDIR}/schedule-${USER}/server>.
This option implies B<--local> (unless overridden later on).

=item B<--port=>I<port> or B<-P> I<port>

Use port number I<port>; default is B<8471>.
This option implies B<--tcp> (unless overridden later on).

=item B<--addr=>I<addr> or B<-A> I<addr>

Bind to I<addr>. The default is 127.0.0.1 (localhost only).
This option implies B<--tcp> (unless overridden later on).

=item B<--port=>I<port> or B<-P> I<port>

Use port number I<port> for interprocess communication-
The default port is B<8471>.

=item B<--addr=>I<addr> or B<-A> I<addr>

Bind/connect to I<addr>. The default is 127.0.0.1 (localhost only).

=item B<--job=>I<jobnr> or B<-j> I<jobnr>

This describes where the job(s) should be inserted into the queue.
The special number B<0> means the end of the queue
(which may be the number of the last queued job or one later, depending
on the selected action); negative numbers count from the end of the list.
The default is B<0>.

This means e.g. that B<schedule queue> will by default queue new jobs after
the end of the queue while e.g. B<schedule insert> will shift the selected
jobs (in their order of selection) to the end of the queue.

=item B<--ok=>I<jobs> or B<-o> I<jobs>

This option can be used repeatedly; all arguments are collected.
I<jobs> can be as in the normal argument list (space-separated).
If used with B<start-or-queue>, B<ok>, B<finished>, B<started>,
check whether the listed jobs have been finished with zero exit status.

=item B<--finished=>I<jobs> or B<-x> I<jobs>

This option can be used repeatedly; all arguments are collected.
I<jobs> can be as in the normal argument list (space-separated).
If used with B<start-or-queue>, B<ok>, B<finished>, B<started>,
check whether the listed jobs have been finished, independent of their
exit status.

=item B<--started=>I<jobs> or B<-s> I<jobs>

This option can be used repeatedly; all arguments are collected.
I<jobs> can be as in the normal argument list (space-separated).
If used with B<start-or-queue>, B<ok>, B<finished>, B<started>,
check whether the listed jobs have been started (finished jobs
are considered as started).

=item B<--no-user> or B<--nouser> or B<-u>

If this option is specified, B<schedule list> will suppress the output of
user, hostname, and B<HOSTTEXT>.

=item B<--no-host> or B<--nohost> or B<-H>

If this option is specified, B<schedule list> will suppress the output of
B<HOSTTEXT>. By default, the value of B<HOSTTEXT> is output in braces;
this can be used to indicate e.g. whether the command is scheduled from
a chroot (and from which). If B<HOSTTEXT> is not specified, the output
of B<uname -m> is used as a default (if nonempty).

=item B<--no-dir> or B<--nodir> or B<-D>

If this option is specified, B<schedule list> will suppress the output of
the current working directory for the scheduled command.

=item B<--keep-dir> or B<--keepdir> or B<-d>

If this option is specified, the current working directory is not shortcut
using the B<HOME> environment variable.

=item B<--no-command> or B<--nocommand> or B<-c>

If this option is specified, B<schedule list> will suppress the output of
the queued command.

=item B<--exit=>I<exitstatus> or B<-e> I<exitstatus>

Sets the I<exitstatus> for unscheduled jobs. The default is B<0>.

=item B<--color> or B<-F>

Try to color even if output is not a terminal.

=item B<--no-color> or B<--nocolor> or B<-p>

Do not color the output.
Setting the environment variable B<ANSI_COLORS_DISABLED> has the same effect.

=item B<--quiet> or B<-q> (accumulative)

Be quiet.

=item B<--help> or B<-h>

Display brief help.

=item B<--man> or B<-?>

Display extended help as a manpage.

=back

=head1 COMMANDS

=over 8

=item B<queue> I<cmd> [I<args> ... I<args>]

Queue I<cmd> I<args> ... I<args> for execution.
The command will be exuted using the shell.

=item B<start> I<cmd> [I<args> ... I<args>]

As B<queue>, but start the command immediately without waiting for a
further signal through B<schedule>.

=item B<start-or-queue> I<cmd> [I<args> ... I<args>]

Act as B<start> if all jobs specified through the options
B<--ok>, B<--finished>, B<--started> meet the corresponding requirements;
otherwise act as B<queue>.
If none of the options B<--ok>, B<--finished>, or B<--started> is specified,
act as if B<--finished :> would have been specified, that is, B<start> is
executed only if there is not any unfinished job in the queue.

=item B<run> I<jobs>

Starts the selected jobs (sequentially) if they have not already
been started. The exit status is the largest exit status of all I<jobs>.
If a job has already been started, the command will wait for its finishing.
If it already has been finished it is not started again, but the exit status
is taken into account.

The command is not race-free, that is, it is somewhat similar to calling
B<schedule run> I<job> for each I<job> separately (for job ranges of the
type B<:> or I<start>B<:> the end being changed dynamically).

This is intentional so that modification of the job queue has effect
to the command while it is running.

=item B<exec> I<jobs>

This is like B<schdeule run> but breaks further execution on the first job
with nonzero exit status. Note that also finished jobs can have nonzero
exit status.

Similarly to B<run>, this command is not race-free.

=item B<bg> I<jobs>

This is like B<schedule run> but starts all non-started jobs in parallel
and then returns.

Similarly to B<run>, this command is not race-free (although a race can
only happen if you simultaneously try to run other commands with B<schedule>
for which there usually is no reason, usually)

=item B<wait> I<jobs>

This waits until all specified jobs have been finished and
returns the largest exit status.

Similarly to B<run>, this command is not race-free,
This is intentional so that modification of the job queue has effect
to the command while it is running.

=item B<parallel> I<jobs>

This is like first running B<schedule bg> and then B<schedule wait>
(including the race between both commands).

=item B<list> I<jobs>

Lists the command line of the queued jobs (unless B<--quiet> is used once).
Outputs whether the job are waiting/running/finished, and in the latter case
which exit status they have (unless B<--quiet> is used twice).

Normally the exit status of this command is 0, but if B<--quiet> is used twice
or more often, the exit status is the largest exit status of the listed
commands.

Similarly to B<run>, this command is not race-free.

=item B<status> I<jobs>

This is like B<--quiet> B<list>.

=item B<ok>|B<finished>|B<started>

This is a more script-friendly and race-free form of B<status>,
without any output (except in error cases):
It returns with exit status 0 if all jobs specified through the options
B<--ok>, B<--finished>, B<--started> meet the corresponding requirements.
(The I<jobs> arguments are quivalent to using the corresponding
B<--ok>, B<--finished>, or B<--started> options with these arguments,
respectively.)
If none of these options is specified and no I<jobs> argument is given,
acts as if the argument B<:> is given for I<jobs>.
If the exit status is nonzero, it is the maximum of B<1> and of all exit values
of jobs specified through B<--ok>.

=item B<remove> I<jobs>

Remove I<jobs> from the list of B<queued> jobs.
Note that if the job is already started it is not stopped, but its exit status
cannot be queried through B<schedule> anymore.

=item B<insert> I<jobs>

The list of queued jobs is ordered differently by shifting all specified I<jobs>
to to the location specified with B<--job>. Thus, if B<--job=1>,
all I<jobs> are shifted to the beginning of the list (renumbering the
previously first jobs). The special value B<--job=0> (default)
means to shift to the end of the list, and negative numbers count from the
end of the list. For instance B<schedule --job=-1 insert :2> will shift the
first two jobs one command before the end of the list.

=item B<cancel> I<jobs>

If I<jobs> are not yet started they will never be started.
If they are running, their exit status will be ignored.
The scheduler is forced to assume that the jobs finished with the
exitstatus specified by B<--cancel> (default is B<0>).

=back

=head1 COPYRIGHT AND LICENSE

Copyright Martin VE<auml>th.
This program is under a BSD type License.

=head1 AUTHOR

Martin VE<auml>th E<lt>martin@mvath.deE<gt>

=cut

# Default for the Options:

my $quiet = 0;
my $cancel = 0;
my $nouser = '';
my $nohost = '';
my $nodir = '';
my $nocommand = '';
my $keepdir = '';
my $destjob = 0;
my @ok = ();
my @finished = ();
my @started = ();

# Global/State variables:

my $unique = undef;
my $socket = undef;
my $exitstatus = 0;
my $devnull = File::Spec->devnull();

my $col_reset = undef;
my $col_waiting = undef;
my $col_running = undef;
my $col_ok = undef;
my $col_failed = undef;
my $col_meta = undef;
my $col_job;
my $col_user = undef;
my $col_host;
my $col_dir = undef;

#
# Commands
#

sub cmd_stop_server {
	return '' unless(&openclient() && &client_send("stop\n$cancel"));
	&client_recv(my $fail);
	unless($quiet) {
		chomp($fail);
		$s->error("jobs failed to close: $fail") if($fail ne '')
	}
	&closeclient();
	1
}

sub cmd_have {
	my ($type) = @_;
	&valid_jobs(@ARGV);
	if(@ARGV) {
		push(@$type, @ARGV);
		&nonempty_have()
	} elsif(!&nonempty_have()) {
		push(@$type, ':')
	}
	return '' unless(&openclient() &&
		&client_send('have' . &have_args()) &&
		&client_recv(my $reply));
	return '' unless(&is_nonnegative($reply));
	&set_exitstatus($reply);
	1
}

sub cmd_queue {
	my ($runmode) = @_;
	my $have = ($runmode eq 'start-or-queue');
	if($have) {
		push(@finished, ':') if(&nonempty_have());
		$runmode .= &have_args();
	}
	return '' unless(&openclient());
	&signals();
	my $cmd = '[' .  &my_user() . '@' . &my_hostname() .
		'(' . &my_hosttext() . ')' .
		&my_cwd() . ']' . &join_quoted(@ARGV);
	my $success = &client_send("$runmode\n$destjob\n" . length($cmd));
	$success = '' unless(&client_recv($unique));
	if($have) {
		$unique =~ m{^([^\n]*)\n(.*)};
		$runmode = $1;
		$unique = $2
	}
	&signals(\&cancel_job);
	$success = '' unless(&client_send($cmd));
	return '' unless($success);
	if($runmode eq 'queue') {
		&client_recv(my $stat, 0);
		unless(defined($stat) && ($stat eq 'run')) {
			$exitstatus = (&is_nonnegative($stat) ? $stat : $cancel);
			return 1
		}
	}
	return '' unless(&closeclient());
	my $sys = system(@ARGV);
	if($sys < 0) {
		$s->error('job could not be executed') unless($quiet);
		$sys = 127
	} elsif($sys & 127) {
		$s->error('job died with signal ' . ($sys & 127) .
			(($sys & 128) ? '' : ' (core dumped)')) unless($quiet);
		$sys = 127
	} else {
		$sys >>= 8;
		$s->error("exit with status " . $sys) if($sys && !$quiet);
	}
	&set_exitstatus($sys);
	&send_status($sys)
}

sub cmd_run {
	&validate_jobs();
	&runner(@_)
}

sub cmd_parallel {
	&validate_jobs();
	return unless(&runner('bg'));
	&runner('wait')
}

{ # Some static variables:
	my $col_reset = undef;
	my $col_waiting = undef;
	my $col_running = undef;
	my $col_ok = undef;
	my $col_failed = undef;
	my $col_meta = undef;
	my $col_job;
sub cmd_list {
	&validate_jobs();
	my $sent = '';
	my $send = ($quiet ? 'status' : 'list');
	for my $a (@ARGV) {
		for(my ($i, $end) = &start_end($a); ($end eq '') || ($i <= $end); ++$i) {
			unless($sent) {
				$sent = 1;
				return '' unless(&openclient())
			}
			return '' unless(&client_send("$send\n$i"));
			&client_recv(my $reply);
			return '' unless($reply =~ s{^(\d+)\n?}{});
			my $job = $1;
			if($job eq '0') {
				last if($end eq '');
				&set_exitstatus(1);
				$s->error("illegal job number $job");
				next
			}
			my $use_color = $s->color_stdout();
			my $reset = ($use_color ? (defined($col_reset) ?
				$col_reset :
				($col_reset = &my_color('reset'))) : '');
			my $stat;
			if($quiet) {
				$stat = $reply
			} else {
				$reply =~ s{^([^\n]*)\n}{};
				$stat = $1
			}
			if($stat eq '-') {
				$stat = ($use_color ? (defined($col_waiting) ?
					$col_waiting :
					($col_waiting = &my_color('bold blue')))
					: '') . 'waiting' . $reset
			} elsif($stat eq '') {
				$stat = ($use_color ? (defined($col_running) ?
					$col_running :
					($col_running = &my_color('bold yellow')))
					: '') . 'running' . $reset
			} elsif(&is_nonnegative($stat)) {
				&set_exitstatus($stat);
				$stat = ($stat ? (defined($col_failed) ?
					$col_failed :
					($col_failed = &my_color('bold red')))
					: (defined($col_ok) ? $col_ok :
					($col_ok = &my_color('bold green'))))
					. $stat . $reset if($use_color)
			} else {
				return ''
			}
			unless($quiet) {
				return '' unless(&client_send("\n") &&
					&client_recv($reply, undef, $reply))
			}
			next unless($quiet < 2);
			if($quiet) {
				print($stat . "\n");
				next
			}
			if($use_color && !defined($col_meta)) {
				$col_meta = &my_color('cyan');
				$col_job = &my_color('bold')
			}
			if($reply =~ s{\[([^@]*)@([^\(]*)\(([^\)]*)\)([^\]]*)\]}{}) {
				$reply = &format_cmd($use_color, $1, $2, $3, $4, $reply)
			} elsif($nocommand) {
				$reply = ''
			}
			if($use_color) {
				print($col_job, $job, $reset, ' ',
				$col_meta, '(', $stat, $col_meta, ')',
				$reset, $reply, "\n")
			} else {
				print($job, ' (', $stat, ')', $reply, "\n")
			}
		}
	}
	return 1 unless($sent);
	&client_send("\n")
}
# Subfunction of cmd_list to format "[user@host(hosttext)dir] cmd"
# In case $use_color, the variables $col_reset, $col_meta are expected.
  # Some static variables:
	my $col_user = undef;
	my $col_host;
	my $col_dir = undef;
sub format_cmd {
	my ($use_color, $user, $host, $hosttext, $dir, $cmd) = @_;
	$cmd = ($nocommand ? '' : ' ' . $cmd);
	my $nopwd = ($nodir || ($dir eq ''));
	return $cmd if($nouser && $nopwd);
	if($use_color) {
		unless($nouser || defined($col_user)) {
			$col_user = &my_color('yellow');
			$col_host = &my_color('green')
		}
		unless($nopwd || defined($col_dir)) {
			$col_dir = &my_color('bold green')
		}
	}
	my $reply = ($use_color ? (' ' . $col_meta . '[') : ' [');
	$reply .= ($use_color ? ($col_user . $user . $col_meta . '@' .
		$col_host . $host . $col_meta) : ($user . '@' . $host)) .
		(($nohost || ($hosttext eq '')) ? ($nopwd ? '' : ':' )
		: ('(' . $hosttext . ')')) unless($nouser);
	$reply .= ($use_color ? ($col_dir . $dir . $col_reset . $col_meta)
		: $dir) unless($nopwd);
	$reply .= ']';
	$reply .= $col_reset if($use_color);
	$reply . $cmd
}}

sub cmd_cancel {
	&validate_jobs();
	my $sent = '';
	for my $a (@ARGV) {
		for(my ($i, $end) = &start_end($a); ($end eq '') || ($i <= $end); ++$i) {
			unless($sent) {
				$sent = 1;
				return '' unless(&openclient())
			}
			return '' unless(&client_send("cancel\n$cancel\n$i"));
			&client_recv(my $reply);
			my ($job, $stat) = split(qr{\s+}, $reply);
			if($job eq '0') {
				last if($end eq '');
				&set_exitstatus(1);
				$s->error("illegal job number $i")
			}
			if($stat) {
				&set_exitstatus(1);
				$s->error("job $job failed to close")
			}
		}
	}
	return 1 unless($sent);
	&client_send("\n")
}

sub cmd_remove {
	&validate_jobs();
	return '' unless(&openclient() &&
		&client_send("remove\n$cancel\n" . join(' ', @ARGV)) &&
		&client_recv(my $failed));
	my @fail = split(qr{\s+}, $failed);
	if(@fail) {
		&set_exitstatus(1);
		$s->error('jobs failed to close: ' . join(' ',@fail))
	}
	1
}

sub cmd_insert {
	&validate_jobs();
	&openclient() && &client_send("insert\n$destjob\n" . join(' ', @ARGV))
}

#
# Functions
#

sub openclient {
	$socket = ($s->tcp() ? new IO::Socket::INET(
		PeerAddr => $s->addr(),
		PeerPort => $s->port(),
		Type => SOCK_STREAM
	) : new IO::Socket::UNIX(
		Peer => $s->file(),
		Type => SOCK_STREAM()
	));
	return 1 if(defined($socket));
	my ($silence) = @_;
	$s->error("unable to setup socket: $!",
		'maybe you should run first: schedule-server &')
			unless(defined($silence) && $silence);
	''
}

sub client_recv {
	return 1 if($s->conn_recv($socket, @_));
	&closeclient(1);
	exit(7)
}

sub client_send {
	$s->conn_send($socket, @_)
}

sub closeclient {
	return 1 unless(defined($socket));
	my $ret = ($socket->close());
	$socket = undef;
	return 1 if($ret);
	my ($silence) = @_;
	$s->error("failed to close socket: $!")
		unless(defined($silence) && $silence);
	''
}

sub runner {
	my ($runmode) = @_;
	my $send = (($runmode eq 'exec') ? 'run' : $runmode) . "\n";
	for my $a (@ARGV) {
		for(my ($i, $end) = &start_end($a); ($end eq '') || ($i <= $end); ++$i) {
			return '' unless(&openclient());
			return '' unless(&client_send("$send$i"));
			&client_recv(my $reply);
			$reply =~ s{^(\d*)\n?}{};
			my $job = $1;
			if($job eq '0') {
				if($end ne '') {
					&set_exitstatus(1);
					$s->error("illegal job number $job")
				}
				last
			}
			if($runmode ne 'bg') {
				&client_recv(my $status, 0);
				$status = $cancel
					unless(&is_nonnegative($status));
				if($status) {
					&set_exitstatus($status);
					return 1 if($runmode eq 'exec');
				}
			}
			return '' unless(&closeclient())
		}
	}
	1
}

sub send_status {
	# Sending exitstatus must cause no errors/warnings:
	&client_send("end\n" . "$unique\n" . "$exitstatus")
		if(&openclient(1));
	&closeclient(1);
	1
}

# Cancel a job (if "schedule queue" is interrupted by a signal):

sub cancel_job {
	&signals();
	&closeclient(1);
	#&send_status($cancel);
	&openclient(1) && &client_send("cancel\n$cancel\n" .
		(defined($unique) ? "u$unique" : "$destjob"))
		&& &client_recv(my $reply)
		&& &client_send("\n");
	exit($cancel)
}


# Check whether @ARGV are valid job specifications.
# Let @ARGV = (':') if there are none and no argument is passed.

sub validate_jobs {
	unless(@ARGV) {
		@ARGV = (':') unless(@_);
		return
	}
	&valid_jobs(@ARGV)
}

sub valid_jobs {
	for my $i (@_) {
		$s->fatal('invalid job specification: ' . &join_quoted($i))
			unless($i =~ m{^(?:[+-]?\d+|(?:[+-]?\d*\:[+-]?\d*))$})
	}
}

# Normalize and validate the value of @ok, @finished, @started.
# Return true if at least one is nonempty.

sub nonempty_have {
	my $ret = '';
	for my $a (\@ok, \@finished, \@started) {
		$ret = 1 if(@$a);
		@$a = split(' ', join(' ', @$a));
		&valid_jobs(@$a);
	}
	$ret
}

# Return passed string for the value of @ok, @finished, @started

sub have_args {
	my $ret = '';
	for my $a (\@ok, \@finished, \@started) {
		$ret .= "\n" . join(' ', @$a)
	}
	$ret
}

# Check whether args are valid job specifications

sub start_end {
	my ($a) = @_;
	return ($a, $a) if($a =~ m{^\d+$});
	$a =~ m{^(\d*)\:(\d*)$};
	((($1 eq '') ? 1 : $1), $2)
}

# increase exitstatus to argument

sub set_exitstatus {
	my ($stat) = @_;
	$exitstatus = $stat if($exitstatus < $stat)
}

# like join(' ', @_), but shell-quote arguments

sub join_quoted {
	my @r;
	for my $i (@_) {
		my $a = $i;
		$a =~ s{\'}{\'\\\'\'}g;
		$a = "'$a'";
		$a =~ s{(\A|[^\\])\'([\w\-\,\.\:\/]*)\'}{$1$2}gm;
		push(@r, ($a ne '') ? $a : "''")
	}
	join(' ', @r)
}

sub check_file {
	my $default = $s->default_filename();
	my $file = $s->file();
	return 1 if(-S $file);
	$s->error("no socket $file exists", 'maybe you should run first: ' .
		&join_quoted('schedule-server',
			($default ? '-l' : ('-f', $file))) . ' &');
	exit(7)
}

{ my $hostname = undef; # a static closure
sub my_hostname {
	return $hostname if(defined($hostname));
	$hostname = $ENV{'HOSTNAME'};
	unless(&is_nonempty($hostname)) {
		eval {
			require File::Which;
			File::Which->import();
			$hostname = hostname()
		};
		$hostname = '' unless($@ && defined($hostname))
	}
	$hostname =~ s{[\(\)\[\]\:]}{.}g;
	$hostname
}}

{ my $hosttext = undef; # a static closure
sub my_hosttext {
	return $hosttext if(defined($hosttext));
	$hosttext = $ENV{'HOSTTEXT'};
	unless(defined($hosttext)) {
		my $olderr = undef;
		$olderr = undef unless(open($olderr, '>&', \*STDERR) && open(STDERR, '>', $devnull));
		$hosttext = `uname -m`;
		open(STDERR, '>&', $olderr) if(defined($olderr));
		$hosttext = '' unless(defined($hosttext));
		chomp($hosttext)
	}
	$hosttext =~ s{[\(\)\[\]]}{.}g;
	$hosttext
}}

{ my $cwd = undef; # a static closure
sub my_cwd {
	return $cwd if(defined($cwd));
	$cwd = getcwd();
	$cwd = '' unless(defined($cwd));
	unless($keepdir) {
		my $home = $ENV{'HOME'};
		if(&is_nonempty($home)) {
			if($home eq $cwd) {
				$cwd = '~'
			} else {
				my $len = length($home);
				$cwd = '~' . substr($cwd, $len) if(
				($len < length($cwd)) &&
				(substr($cwd, 0, $len + 1) eq ($home . '/')))
			}
		}
	}
	$cwd =~ s{[\[\]]}{?}g;
	$cwd
}}

#
# Now the main program:
#

if(exists($ENV{'SCHEDULE_OPTS'})) {
	unshift(@ARGV, &env_to_array('SCHEDULE_OPTS'))
}

# Parse Options:

$s->get_options(
	'exit|e=i', \$cancel,
	'no-user|nouser|u', \$nouser,
	'no-host|nohost|H', \$nohost,
	'no-dir|nodir|D', \$nodir,
	'no-command|nocommand|c', \$nocommand,
	'keep-dir|keepdir|d', \$keepdir,
	'job|j=i', \$destjob,
	'ok|o=s', \@ok,
	'finished|x=s', \@finished,
	'started|s=s', \@started,
	'quiet|q+', \$quiet
);

# Postprocess options:

$s->check_options();
$s->fatal("illegal --exit $cancel")
	unless(&is_nonnegative($cancel) && $cancel <= 0xFF);
&check_file() unless($s->tcp());

# Process command:

my $action = shift(@ARGV);
$action = '' unless(defined($action));
my $ret;
if($action =~ m{^sto}i) {
	$ret = &cmd_stop_server()
} elsif($action =~ m{^(?:re|d)}i) {
	$ret = &cmd_remove()
} elsif($action =~ m{^r}i) {
	$ret = &cmd_run('run')
} elsif($action =~ m{^(?:e|x)}i) {
	$ret = &cmd_run('exec')
} elsif($action =~ m{^b}i) {
	$ret = &cmd_run('bg')
} elsif($action =~ m{^p}i) {
	$ret = &cmd_parallel()
} elsif($action =~ m{^w}i) {
	$ret = &cmd_run('wait')
} elsif($action =~ m{^l}i) {
	$ret = &cmd_list()
} elsif($action =~ m{^stat}i) {
	++$quiet;
	$ret = &cmd_list()
} elsif($action =~ m{^o}i) {
	$ret = &cmd_have(\@ok)
} elsif($action =~ m{^f}i) {
	$ret = &cmd_have(\@finished)
} elsif($action =~ m{^starte}i) {
	$ret = &cmd_have(\@started)
} elsif($action =~ m{^(i|m|sh)}i) {
	$ret = &cmd_insert()
} elsif($action =~ m{q.*s|s.*q}i) {
	$ret = &cmd_queue('start-or-queue')
} elsif($action =~ m{^q}i) {
	$ret = &cmd_queue('queue')
} elsif($action =~ m{^s}i) {
	$ret = &cmd_queue('start')
} elsif($action =~ m{^c}i) {
	$ret = &cmd_cancel()
} else {
	pod2usage(2)
}
$exitstatus = 7 unless(&closeclient() && $ret);
exit($exitstatus);
