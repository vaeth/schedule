#compdef schedule schedule-server
local curcontext="$curcontext" state state_descr line
typeset -A opt_args
local service_opts
service_opts=(
'(1 * -)'{'--help','-h'}'[print a brief help]'
'(1 * -)'{'--man','-\\?'}'[show extended help as a manpage]'
'(1 * -)'{'--version','-V'}'[print version and exit]'
{'(--port)-P+','(-P)--port='}'[PORT (set TCP port)]:port:(127.0.0.1)'
{'(--file)-f+','(-f)--file='}'[FILE (use FILE as socket)]:socket:_file "-g*(=)"'
{'(--addr)-A+','(-A)--addr='}'[ADDR (set address)]:port:(8471)'
{'(--timeout)-T+','(-T)--timeout='}'[SECONDS (set timeout)]:seconds:(10)'
'(--local -l '{'--tcp)-t','-t)--tcp'}'[use tcp socket (port)]'
'(--tcp -t '{'--local)-l','-l)--local'}'[use unix domain socket (file)]'
'(--no-color -nocolor -p '{'-F)--color','(--color)-F'}'[force color on non-terminal]'
'(--color -F '{'--no-color --nocolor)-p','--nocolor -p)--no-color','--no-color -E)--nocolor'}'[non-colored output]'
)
case ${service} in
(*server)
	service_opts+=(
{'(--skip-check)-S','(-S)--skip-check'}'[skip permission check (dangerous!)]'
{'(--umask)-m+','(-m)--umask='}'[UMASK (set UMASK)]:umask:(0077)'
{'(--user)-u+','(-u)--user='}'[USER (use USER permissions)]:user name:_users'
{'(--group)-g+','(-g)--group='}'[GROUP (use GROUP permissions)]:group name:_groups'
'(--user -u '{'--uid)-U+','-u)--uid='}'[UID (use UID permissions)]:user id:(65534)'
'(--group -g '{'--gid)-G+','-G)--gid='}'[GID (use GID permissions)]:group id:(65534)'
'(--no-change-user -n '{'--change-user)-c','-c)--change-user'}'[change user permissions]'
'(--no-change-group -N '{'--change-group)-C','-C)--change-group'}'[change group permissions]'
'(--keep-permissions -k --change-user -c --change-group -C '{'--change-permissions)-K','-K)--change-permissions'}'[change user/group permissions]'
'(--user -u --uid -U '{'--no-change-user)-n','-n)--no-change-user'}'[do not change user permissions]'
'(--group -g --gid -G '{'--no-change-group)-N','-N)--no-change-group'}'[do not change group permissions]'
'(--change-permissions -K --user -u --uid -U --group -g --gid -G --no-change-user -n '{'--keep-permissions)-k','-k)--keep-permissions'}'[do not change user/group permissions]'
'1:command:->cmds'
);;
(*)
	service_opts+=(
{'(--exit)-e+','(-e)--exit='}'[STATUS (set exitstatus)]:exitstatus:(0)'
{'(--job)-j+','(-j)--job='}'[JOB (set jobnumber)]:jobnumber:(0)'
'*'{'-x+','--finished='}'[have all jobs finished (accumulative)]:job range:(\:)'
'*'{'-o+','--ok='}'[have all jobs succeeded (accumulative)]:job range:(\:)'
'*'{'-s+','--started='}'[have all jobs started (accumulative)]:job range:(\:)'
'*'{'-q','--quiet'}'[be more quiet (accumulative)]'
'1:command:->cmds'
'2::command:->normal'
);;
esac
_arguments -C -s -S -A '-*' : $service_opts
local ret=$?
case $state in
(*cmds)
	local cmds
	cmds=(
	'help:print a brief help'
	'man:show extended help as a manpage'
	)
	[[ $service == *server ]] || cmds+=(
	'stop-server:stop schedule-server'
	'queue:queue job for later execution'
	{'s','start'}':queue and run job'
	{'sq','qs','start-or-queue'}':queue job and run it if the rest is finished'
	'run:start queued job sequentially even if failure'
	{'x','exec'}':start queued job sequentially until failure'
	'bg:start queued jobs parallel and return'
	'parallel:start queued jobs parallel and wait'
	'wait:wait until queued running jobs are finished'
	'list:list queued jobs'
	'status:status of queued jobs'
	'ok:whether all jobs have finished ok'
	'finished:whether all jobs have finished'
	'started:whether all jobs have started'
	{'delete','remove'}':remove queued jobs from list'
	{'move','shift','insert'}':shift queued jobs in list'
	'cancel:cancel queued jobs'
	)
	_describe -t commands 'command' cmds
	ret=$?;;
(*normal)
	shift $CURRENT words
	CURRENT=1
	_normal
	ret=$?;;
esac
return ret
